{
{ "__CPROVER_danger_execute",
  "#line 1 \"<builtin-library-__CPROVER_danger_execute>\"\n"
  "\n"
  "#ifndef __CPROVER_cegis_number_of_vars\n"
  "#define __CPROVER_cegis_number_of_vars 2\n"
  "#endif\n"
  "#ifndef __CPROVER_cegis_number_of_consts\n"
  "#define __CPROVER_cegis_number_of_consts 1\n"
  "#endif\n"
  "#ifndef __CPROVER_cegis_number_of_ops\n"
  "#define __CPROVER_cegis_number_of_ops 3\n"
  "#endif\n"
  "#ifndef __CPROVER_cegis_max_solution_size\n"
  "#define __CPROVER_cegis_max_solution_size 1\n"
  "#endif\n"
  "\n"
  "const void *__CPROVER_cegis_OPS[__CPROVER_cegis_number_of_ops];\n"
  "void *__CPROVER_cegis_RESULT_OPS[__CPROVER_cegis_max_solution_size];\n"
  "\n"
  "typedef unsigned char opcodet;\n"
  "typedef unsigned char opt;\n"
  "struct __CPROVER_cegis_instructiont\n"
  "{\n"
  "  opcodet opcode;\n"
  "  opt op0;\n"
  "  opt op1;\n"
  "  opt op2;\n"
  "};\n"
  "\n"
  "#define __CPROVER_cegis_max_instruction 24u\n"
  "\n"
  "void __CPROVER_danger_execute(struct __CPROVER_cegis_instructiont *program,\n"
  "                              unsigned char size)\n"
  "{\n"
  "  for (unsigned char i = 0; i < size; ++i)\n"
  "  {\n"
  "#define opcode program[i].opcode\n"
  "    __CPROVER_assume(opcode <= __CPROVER_cegis_max_instruction);\n"
  "    const unsigned int op0_id=program[i].op0;\n"
  "    const unsigned int op1_id=program[i].op1;\n"
  "    const unsigned int op2_id=program[i].op2;\n"
  "    const unsigned int max_op_index=__CPROVER_cegis_number_of_vars + i;\n"
  "    __CPROVER_assume(op0_id < max_op_index && op1_id < max_op_index && op2_id < max_op_index\n"
  "        && (op0_id >= __CPROVER_cegis_number_of_consts || op1_id >= __CPROVER_cegis_number_of_consts  || op2_id >= __CPROVER_cegis_number_of_consts)\n"
  "        && (opcode > 5u || op0_id <= op1_id) && (opcode < 21u || !op1_id)\n"
  "        && (opcode == 9u || !op2_id)\n"
  "        && (opcode != 9u || op0_id != op2_id || op1_id <= op2_id));\n"
  "    const unsigned int * const op0_ptr=__CPROVER_cegis_OPS[op0_id];\n"
  "    const unsigned int * const op1_ptr=__CPROVER_cegis_OPS[op1_id];\n"
  "    const unsigned int * const op2_ptr=__CPROVER_cegis_OPS[op2_id];\n"
  "    __CPROVER_assume(op0_ptr && op1_ptr && op2_ptr);  // No null pointers in op array\n"
  "    const unsigned int op0=*op0_ptr;\n"
  "    const unsigned int op1=*op1_ptr;\n"
  "    __CPROVER_assume((opcode != 19 && opcode != 20) || op1); // Avoid div by 0.\n"
  "    const unsigned int op2=*op2_ptr;\n"
  "#define sop0 ((int) op0)\n"
  "#define sop1 ((int) op1)\n"
  "#define sop2 ((int) op2)\n"
  "\n"
  "    unsigned int result;\n"
  "    if (opcode < 15)\n"
  "      if (opcode < 7)\n"
  "        if (opcode < 3)\n"
  "          if (opcode < 1)\n"
  "    __CPROVER_cegis_opcode_0: result=op0 + op1;\n"
  "          else if (opcode < 2)\n"
  "    __CPROVER_cegis_opcode_1: result=op0 * op1;\n"
  "          else\n"
  "    __CPROVER_cegis_opcode_2: result=op0 &op1;\n"
  "        else\n"
  "          if (opcode < 5)\n"
  "            if  (opcode < 4)\n"
  "    __CPROVER_cegis_opcode_3: result=op0 | op1;\n"
  "            else\n"
  "    __CPROVER_cegis_opcode_4: result=op0 ^ op1;\n"
  "          else if (opcode < 6)\n"
  "    __CPROVER_cegis_opcode_5: result=op0 != op1;\n"
  "            else\n"
  "    __CPROVER_cegis_opcode_6: result=!op0 || op1;\n"
  "      else\n"
  "        if (opcode < 11)\n"
  "          if (opcode < 9)\n"
  "            if (opcode < 8)\n"
  "    {\n"
  "    __CPROVER_cegis_opcode_first_7: result=op0 < op1;\n"
  "    if (result) result=op0;\n"
  "    else __CPROVER_cegis_opcode_last_7: result=op1;\n"
  "    }\n"
  "            else\n"
  "    {\n"
  "    __CPROVER_cegis_opcode_first_8: result=op0 > op1;\n"
  "    if (result) result=op0;\n"
  "    else __CPROVER_cegis_opcode_last_8: result=op1;\n"
  "    }\n"
  "          else if (opcode < 10)\n"
  "    {\n"
  "    __CPROVER_cegis_opcode_first_9: if (op0) result=op1;\n"
  "    else __CPROVER_cegis_opcode_last_9: result=op2;\n"
  "    }\n"
  "          else\n"
  "    __CPROVER_cegis_opcode_10: result=op0 - op1;\n"
  "        else\n"
  "          if (opcode < 13)\n"
  "            if (opcode < 12)\n"
  "            {\n"
  "    __CPROVER_cegis_opcode_first_11: result=op1;\n"
  "    //result%=sizeof(op0);\n"
  "    result%=32u;\n"
  "    __CPROVER_cegis_opcode_last_11: result=op0 << result;\n"
  "            }\n"
  "            else\n"
  "            {\n"
  "    __CPROVER_cegis_opcode_first_12:  result=op1;\n"
  "    //result%=sizeof(op0);\n"
  "    result%=32u;\n"
  "    __CPROVER_cegis_opcode_last_12:  result=op0 >> result;\n"
  "            }\n"
  "          else if (opcode < 14)\n"
  "          {\n"
  "    __CPROVER_cegis_opcode_first_13: result=op1;\n"
  "    //result%=sizeof(op0);\n"
  "    result%=32u;\n"
  "    __CPROVER_cegis_opcode_last_13: result=op0 >> result;\n"
  "          }\n"
  "          else\n"
  "          {\n"
  "    __CPROVER_cegis_opcode_first_14: result=op1;\n"
  "    //result%=sizeof(op0);\n"
  "    result%=32u;\n"
  "    __CPROVER_cegis_opcode_last_14: result=sop0 >> result;\n"
  "          }\n"
  "    else if (opcode < 19)\n"
  "      if (opcode < 17)\n"
  "        if (opcode < 16)\n"
  "    __CPROVER_cegis_opcode_15: result=op0 <= op1;\n"
  "        else\n"
  "    __CPROVER_cegis_opcode_16: result=op0 < op1;\n"
  "      else if (opcode < 18)\n"
  "    __CPROVER_cegis_opcode_17: result=sop0 <= sop1;\n"
  "      else\n"
  "    __CPROVER_cegis_opcode_18: result=sop0 < sop1;\n"
  "    else if (opcode < 23)\n"
  "      if (opcode < 21)\n"
  "        if (opcode < 20)\n"
  "    __CPROVER_cegis_opcode_19: result=op0 / op1;\n"
  "        else\n"
  "    __CPROVER_cegis_opcode_20: result=op0 % op1;\n"
  "      else if (opcode < 22)\n"
  "    __CPROVER_cegis_opcode_21: result=-op0;\n"
  "      else\n"
  "    __CPROVER_cegis_opcode_22: result=~op0;\n"
  "    else if (opcode < 24)\n"
  "    //__CPROVER_cegis_opcode_23: result=0u;\n"
  "    __CPROVER_cegis_opcode_23: result=sop0 == -1;\n"
  "    else\n"
  "      __CPROVER_cegis_opcode_24: result=op0;\n"
  "    //__CPROVER_cegis_opcode_24: result=sop0 != -1;\n"
  "\n"
  "    *(unsigned int *)__CPROVER_cegis_RESULT_OPS[i]=result;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "isalnum",
  "#line 1 \"<builtin-library-isalnum>\"\n"
  "\n"
  "int isalnum(int c)\n"
  "{ return (c>='a' && c<='z') || (c>='A' && c<='Z') || (c>='0' && c<='9'); }\n"
  "\n"
},
{ "isalpha",
  "#line 1 \"<builtin-library-isalpha>\"\n"
  "\n"
  "int isalpha(int c)\n"
  "{ return (c>='a' && c<='z') || (c>='A' && c<='Z'); }\n"
  "\n"
},
{ "isblank",
  "#line 1 \"<builtin-library-isblank>\"\n"
  "\n"
  "int isblank(int c)\n"
  "{ return c==' ' || c=='\\t'; }\n"
  "\n"
},
{ "iscntrl",
  "#line 1 \"<builtin-library-iscntrl>\"\n"
  "\n"
  "int iscntrl(int c)\n"
  "{ return (c>=0 && c<='\\037') || c=='\\177'; }\n"
  "\n"
},
{ "isdigit",
  "#line 1 \"<builtin-library-isdigit>\"\n"
  "\n"
  "int isdigit(int c)\n"
  "{ return c>='0' && c<='9'; }\n"
  "\n"
},
{ "isgraph",
  "#line 1 \"<builtin-library-isgraph>\"\n"
  "\n"
  "int isgraph(int c)\n"
  "{ return c>='!' && c<='~'; }\n"
  "\n"
},
{ "islower",
  "#line 1 \"<builtin-library-islower>\"\n"
  "\n"
  "int islower(int c)\n"
  "{ return c>='a' && c<='z'; }\n"
  "\n"
},
{ "isprint",
  "#line 1 \"<builtin-library-isprint>\"\n"
  "\n"
  "int isprint(int c)\n"
  "{ return c>=' ' && c<='~'; }\n"
  "\n"
},
{ "ispunct",
  "#line 1 \"<builtin-library-ispunct>\"\n"
  "\n"
  "int ispunct(int c)\n"
  "{ return c=='!' ||\n"
  "         c=='\"' ||\n"
  "         c=='#' ||\n"
  "         c=='$' ||\n"
  "         c=='%' ||\n"
  "         c=='&' ||\n"
  "         c=='\\'' ||\n"
  "         c=='(' ||\n"
  "         c==')' ||\n"
  "         c=='*' ||\n"
  "         c=='+' ||\n"
  "         c==',' ||\n"
  "         c=='-' ||\n"
  "         c=='.' ||\n"
  "         c=='/' ||\n"
  "         c==':' ||\n"
  "         c==';' ||\n"
  "         c=='<' ||\n"
  "         c=='=' ||\n"
  "         c=='>' ||\n"
  "         c=='?' ||\n"
  "         c=='@' ||\n"
  "         c=='[' ||\n"
  "         c=='\\\\' ||\n"
  "         c==']' ||\n"
  "         c=='^' ||\n"
  "         c=='_' ||\n"
  "         c=='`' ||\n"
  "         c=='{' ||\n"
  "         c=='|' ||\n"
  "         c=='}' ||\n"
  "         c=='~'; }\n"
  "\n"
},
{ "isspace",
  "#line 1 \"<builtin-library-isspace>\"\n"
  "\n"
  "int isspace(int c)\n"
  "{ return c=='\\t' ||\n"
  "         c=='\\n' ||\n"
  "         c=='\\v' ||\n"
  "         c=='\\f' ||\n"
  "         c=='\\r' ||\n"
  "         c==' '; }\n"
  "\n"
},
{ "isupper",
  "#line 1 \"<builtin-library-isupper>\"\n"
  "\n"
  "int isupper(int c)\n"
  "{ return c>='A' && c<='Z'; }\n"
  "\n"
},
{ "isxdigit",
  "#line 1 \"<builtin-library-isxdigit>\"\n"
  "\n"
  "int isxdigit(int c)\n"
  "{ return (c>='A' && c<='F') || (c>='a' && c<='f') || (c>='0' && c<='9'); }\n"
  "\n"
},
{ "tolower",
  "#line 1 \"<builtin-library-tolower>\"\n"
  "\n"
  "int tolower(int c)\n"
  "{ return (c>='A' && c<='Z')?c+('a'-'A'):c; }\n"
  "\n"
},
{ "toupper",
  "#line 1 \"<builtin-library-toupper>\"\n"
  "\n"
  "int toupper(int c)\n"
  "{ return (c>='a' && c<='z')?c-('a'-'A'):c; }\n"
},
{ "err",
  "#line 1 \"<builtin-library-err>\"\n"
  "\n"
  "#ifndef __CPROVER_ERR_H_INCLUDED\n"
  "#include <err.h>\n"
  "#define __CPROVER_ERR_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void err(int eval, const char *fmt, ...)\n"
  "{\n"
  "  (void)eval;\n"
  "  (void)*fmt;\n"
  "  abort();\n"
  "}\n"
  "\n"
},
{ "errx",
  "#line 1 \"<builtin-library-errx>\"\n"
  "\n"
  "#ifndef __CPROVER_ERR_H_INCLUDED\n"
  "#include <err.h>\n"
  "#define __CPROVER_ERR_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void errx(int eval, const char *fmt, ...)\n"
  "{\n"
  "  (void)eval;\n"
  "  (void)*fmt;\n"
  "  abort();\n"
  "}\n"
  "\n"
},
{ "warn",
  "#line 1 \"<builtin-library-warn>\"\n"
  "\n"
  "#ifndef __CPROVER_ERR_H_INCLUDED\n"
  "#include <err.h>\n"
  "#define __CPROVER_ERR_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void warn(const char *fmt, ...)\n"
  "{\n"
  "  (void)*fmt;\n"
  "}\n"
  "\n"
},
{ "warnx",
  "#line 1 \"<builtin-library-warnx>\"\n"
  "\n"
  "#ifndef __CPROVER_ERR_H_INCLUDED\n"
  "#include <err.h>\n"
  "#define __CPROVER_ERR_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void warnx(const char *fmt, ...)\n"
  "{\n"
  "  (void)*fmt;\n"
  "}\n"
},
{ "__error",
  "#line 1 \"<builtin-library-__error>\"\n"
  "\n"
  "// This is used on MacOS to return the address of a\n"
  "// variable used for the errno macro.\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "int *__error(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
  "\n"
},
{ "__errno_location",
  "#line 1 \"<builtin-library-__errno_location>\"\n"
  "\n"
  "// This is used on Linux to return the address of a\n"
  "// variable used for the errno macro.\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "int *__errno_location(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
  "\n"
},
{ "_errno",
  "#line 1 \"<builtin-library-_errno>\"\n"
  "\n"
  "// This is used on Windows to return the address of a\n"
  "// variable used for the errno macro.\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "int *_errno(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
  "\n"
},
{ "__errno",
  "#line 1 \"<builtin-library-__errno>\"\n"
  "\n"
  "// This has been spotted in CYGWIN\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "extern int *__errno(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
  "\n"
},
{ "___errno",
  "#line 1 \"<builtin-library-___errno>\"\n"
  "\n"
  "// This has been spotted on Solaris\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "extern int *___errno(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
},
{ "fcntl",
  "#line 1 \"<builtin-library-fcntl>\"\n"
  "\n"
  "#ifndef __CPROVER_FCNTL_H_INCLUDED\n"
  "#include <fcntl.h>\n"
  "#define __CPROVER_FCNTL_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int fcntl(int fd, int cmd, ...)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "  (void)fd;\n"
  "  (void)cmd;\n"
  "  return return_value;\n"
  "}\n"
},
{ "fegetround",
  "#line 1 \"<builtin-library-fegetround>\"\n"
  "\n"
  "#include <fenv.h>\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "int fegetround(void)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  // CPROVER uses the x86 numbering of the rounding modes\n"
  "  return\n"
  "         #ifdef FE_DOWNWARD\n"
  "         __CPROVER_rounding_mode==1?FE_DOWNWARD:\n"
  "         #endif\n"
  "         __CPROVER_rounding_mode==0?FE_TONEAREST:\n"
  "         __CPROVER_rounding_mode==3?FE_TOWARDZERO:\n"
  "         #ifdef FE_UPWARD\n"
  "         __CPROVER_rounding_mode==2?FE_UPWARD:\n"
  "         #endif\n"
  "         -1;\n"
  "}\n"
  "\n"
},
{ "fesetround",
  "#line 1 \"<builtin-library-fesetround>\"\n"
  "\n"
  "#include <fenv.h>\n"
  "\n"
  "int fesetround(int rounding_mode)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  // CPROVER uses the x86 numbering of the rounding modes\n"
  "  __CPROVER_rounding_mode=\n"
  "    #ifdef FE_DOWNWARD\n"
  "    rounding_mode==FE_DOWNWARD?1:\n"
  "    #endif\n"
  "    rounding_mode==FE_TONEAREST?0:\n"
  "    rounding_mode==FE_TOWARDZERO?3:\n"
  "    #ifdef FE_UPWARD\n"
  "    rounding_mode==FE_UPWARD?2:\n"
  "    #endif\n"
  "    0;\n"
  "  return 0; // we never fail\n"
  "}\n"
},
{ "_controlfp",
  "#line 1 \"<builtin-library-_controlfp>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <float.h>\n"
  "\n"
  "__CPROVER_thread_local unsigned __CPROVER_fpu_control_word;\n"
  "\n"
  "unsigned int _controlfp(\n"
  "  unsigned int new_value,\n"
  "  unsigned int mask)\n"
  "{\n"
  "  __CPROVER_fpu_control_word=\n"
  "    (__CPROVER_fpu_control_word&~mask)|new_value;\n"
  "\n"
  "  if((mask&_MCW_RC)!=0)\n"
  "    __CPROVER_rounding_mode=(new_value&_MCW_RC)>>8;\n"
  "\n"
  "  return __CPROVER_fpu_control_word;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_status87",
  "#line 1 \"<builtin-library-_status87>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "__CPROVER_thread_local unsigned __CPROVER_fpu_control_word;\n"
  "\n"
  "unsigned int _status87(void)\n"
  "{\n"
  "  return __CPROVER_fpu_control_word;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_statusfp",
  "#line 1 \"<builtin-library-_statusfp>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "__CPROVER_thread_local unsigned __CPROVER_fpu_control_word;\n"
  "\n"
  "unsigned int _statusfp(void)\n"
  "{\n"
  "  return __CPROVER_fpu_control_word;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_statusfp2",
  "#line 1 \"<builtin-library-_statusfp2>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "__CPROVER_thread_local unsigned __CPROVER_fpu_control_word;\n"
  "\n"
  "void _statusfp2(unsigned int *px86, unsigned int *pSSE2)\n"
  "{\n"
  "  unsigned SSE2_status;\n"
  "  *px86=__CPROVER_fpu_control_word;\n"
  "  *pSSE2=SSE2_status; // nondet\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_isnan",
  "#line 1 \"<builtin-library-_isnan>\"\n"
  "\n"
  "int _isnan(double x)\n"
  "{\n"
  "  return __CPROVER_isnand(x);\n"
  "}\n"
  "\n"
},
{ "__builtin_flt_rounds",
  "#line 1 \"<builtin-library-__builtin_flt_rounds>\"\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "int __builtin_flt_rounds(void)\n"
  "{\n"
  "  // This is a clang builtin for FLT_ROUNDS\n"
  "  // The magic numbers are C99 and different from the\n"
  "  // x86 encoding that CPROVER uses.\n"
  "  return __CPROVER_rounding_mode==0?1: // to nearest\n"
  "         __CPROVER_rounding_mode==1?3: // downward\n"
  "         __CPROVER_rounding_mode==2?2: // upward\n"
  "         __CPROVER_rounding_mode==3?0: // to zero\n"
  "         -1;\n"
  "}\n"
  "\n"
},
{ "__flt_rounds",
  "#line 1 \"<builtin-library-__flt_rounds>\"\n"
  "\n"
  "int __builtin_flt_rounds(void);\n"
  "\n"
  "int __flt_rounds(void)\n"
  "{\n"
  "  // Spotted on FreeBSD\n"
  "  return __builtin_flt_rounds();\n"
  "}\n"
},
{ "__builtin_ia32_sfence",
  "#line 1 \"<builtin-library-__builtin_ia32_sfence>\"\n"
  "\n"
  "#if defined(__i386__) || defined(__x86_64__)\n"
  "\n"
  "void __builtin_ia32_sfence(void)\n"
  "{\n"
  "  __asm(\"sfence\");\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "__builtin_ia32_lfence",
  "#line 1 \"<builtin-library-__builtin_ia32_lfence>\"\n"
  "\n"
  "#if defined(__i386__) || defined(__x86_64__)\n"
  "\n"
  "void __builtin_ia32_lfence(void)\n"
  "{\n"
  "  __asm(\"lfence\");\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "__builtin_ia32_mfence",
  "#line 1 \"<builtin-library-__builtin_ia32_mfence>\"\n"
  "\n"
  "#if defined(__i386__) || defined(__x86_64__)\n"
  "\n"
  "void __builtin_ia32_mfence(void)\n"
  "{\n"
  "  __asm(\"mfence\");\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "__sync_synchronize",
  "#line 1 \"<builtin-library-__sync_synchronize>\"\n"
  "\n"
  "void __sync_synchronize(void)\n"
  "{\n"
  "  // WARNING: this was a NOP before gcc 4.3.1,\n"
  "  // but is now believed to be the strongest possible barrier.\n"
  "\n"
  "  #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) >= 40301\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "__atomic_test_and_set",
  "#line 1 \"<builtin-library-__atomic_test_and_set>\"\n"
  "\n"
  "void __atomic_thread_fence(int memorder);\n"
  "\n"
  "_Bool __atomic_test_and_set(void *ptr, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  _Bool result = *(char *)ptr == 1;\n"
  "  *(char *)ptr = 1;\n"
  "  __atomic_thread_fence(memorder);\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "__atomic_clear",
  "#line 1 \"<builtin-library-__atomic_clear>\"\n"
  "\n"
  "void __atomic_thread_fence(int memorder);\n"
  "\n"
  "void __atomic_clear(_Bool *ptr, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  *(char *)ptr = 0;\n"
  "  __atomic_thread_fence(memorder);\n"
  "  __CPROVER_atomic_end();\n"
  "}\n"
  "\n"
},
{ "__atomic_thread_fence",
  "#line 1 \"<builtin-library-__atomic_thread_fence>\"\n"
  "\n"
  "#if __STDC_VERSION__ >= 201112L\n"
  "// GCC 4.8 did claim to support C++11, but failed to ship stdatomic.h\n"
  "#  if !defined(__GNUC__) || (__GNUC__ * 100 + __GNUC_MINOR__) >= 409\n"
  "#    include <stdatomic.h>\n"
  "#  endif\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELAXED\n"
  "#  define __ATOMIC_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_CONSUME\n"
  "#  define __ATOMIC_CONSUME 1\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQUIRE\n"
  "#  define __ATOMIC_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELEASE\n"
  "#  define __ATOMIC_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQ_REL\n"
  "#  define __ATOMIC_ACQ_REL 4\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_SEQ_CST\n"
  "#  define __ATOMIC_SEQ_CST 5\n"
  "#endif\n"
  "\n"
  "void __atomic_thread_fence(int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  if(memorder == __ATOMIC_CONSUME || memorder == __ATOMIC_ACQUIRE)\n"
  "    __CPROVER_fence(\"RRfence\", \"RWfence\", \"RRcumul\", \"RWcumul\");\n"
  "  else if(memorder == __ATOMIC_RELEASE)\n"
  "    __CPROVER_fence(\"WRfence\", \"WWfence\", \"WRcumul\", \"WWcumul\");\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_SEQ_CST)\n"
  "    __CPROVER_fence(\n"
  "      \"WWfence\",\n"
  "      \"RRfence\",\n"
  "      \"RWfence\",\n"
  "      \"WRfence\",\n"
  "      \"WWcumul\",\n"
  "      \"RRcumul\",\n"
  "      \"RWcumul\",\n"
  "      \"WRcumul\");\n"
  "}\n"
  "\n"
},
{ "__atomic_signal_fence",
  "#line 1 \"<builtin-library-__atomic_signal_fence>\"\n"
  "\n"
  "void __atomic_thread_fence(int memorder);\n"
  "\n"
  "void __atomic_signal_fence(int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __atomic_thread_fence(memorder);\n"
  "}\n"
  "\n"
  "// __SZH_ADD_BEGIN__\n"
  "\n"
},
{ "__atomic_store",
  "#line 1 \"<builtin-library-__atomic_store>\"\n"
  "\n"
  "inline void __atomic_store(void* loc, void* val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_store(loc, val, memorder);\n"
  "}\n"
  "\n"
},
{ "__atomic_store_n",
  "#line 1 \"<builtin-library-__atomic_store_n>\"\n"
  "\n"
  "void __atomic_store_n(void* loc, void* val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_store_n(loc, val, memorder);\n"
  "}\n"
  "\n"
},
{ "__atomic_load",
  "#line 1 \"<builtin-library-__atomic_load>\"\n"
  "\n"
  "void __atomic_load(void* loc, void* ret, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_load(loc, ret, memorder);\n"
  "}\n"
  "\n"
},
{ "__atomic_load_n",
  "#line 1 \"<builtin-library-__atomic_load_n>\"\n"
  "\n"
  "void __atomic_load_n(void* loc, void* ret, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_load_n(loc, ret, memorder);\n"
  "}\n"
  "\n"
},
{ "__atomic_compare_exchange",
  "#line 1 \"<builtin-library-__atomic_compare_exchange>\"\n"
  "\n"
  "#ifndef __ATOMIC_RELAXED\n"
  "#  define __ATOMIC_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_CONSUME\n"
  "#  define __ATOMIC_CONSUME 1\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQUIRE\n"
  "#  define __ATOMIC_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELEASE\n"
  "#  define __ATOMIC_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQ_REL\n"
  "#  define __ATOMIC_ACQ_REL 4\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_SEQ_CST\n"
  "#  define __ATOMIC_SEQ_CST 5\n"
  "#endif\n"
  "\n"
  "_Bool __atomic_compare_exchange(int* left, int* right, int val, int is_weak, int memorder1, int memorder2)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  int __atomic_compare_exchange_right_load;\n"
  "  __atomic_compare_exchange_right_load = *right;\n"
  "  int __atomic_compare_exchange_left_load;\n"
  "  if(memorder1 == __ATOMIC_SEQ_CST)\n"
  "    __atomic_load(left, &__atomic_compare_exchange_left_load, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder1 == __ATOMIC_ACQ_REL || memorder1 == __ATOMIC_ACQUIRE)\n"
  "    __atomic_load(left, &__atomic_compare_exchange_left_load, __ATOMIC_ACQUIRE);\n"
  "  else\n"
  "    __atomic_load(left, &__atomic_compare_exchange_left_load, __ATOMIC_RELAXED);\n"
  "\n"
  "  _Bool equal = (__atomic_compare_exchange_right_load == __atomic_compare_exchange_left_load);\n"
  "  if(equal)\n"
  "  {\n"
  "    if(memorder1 == __ATOMIC_SEQ_CST)\n"
  "      __atomic_store(right, &val, __ATOMIC_SEQ_CST);\n"
  "    else if(memorder1 == __ATOMIC_ACQ_REL || memorder1 == __ATOMIC_RELEASE)\n"
  "      __atomic_store(right, &val, __ATOMIC_RELEASE);\n"
  "    else\n"
  "      __atomic_store(right, &val, __ATOMIC_RELAXED);\n"
  "    \n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    *right = __atomic_compare_exchange_left_load;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  return equal;\n"
  "}\n"
  "\n"
},
{ "__atomic_exchange",
  "#line 1 \"<builtin-library-__atomic_exchange>\"\n"
  "\n"
  "#ifndef __ATOMIC_RELAXED\n"
  "#  define __ATOMIC_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_CONSUME\n"
  "#  define __ATOMIC_CONSUME 1\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQUIRE\n"
  "#  define __ATOMIC_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELEASE\n"
  "#  define __ATOMIC_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQ_REL\n"
  "#  define __ATOMIC_ACQ_REL 4\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_SEQ_CST\n"
  "#  define __ATOMIC_SEQ_CST 5\n"
  "#endif\n"
  "\n"
  "void __atomic_exchange(int* loc, int* val, int* ret, int memorder)\n"
  "{\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  int __atomic_exchange_old_val;\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_load(loc, &__atomic_exchange_old_val, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_ACQUIRE)\n"
  "    __atomic_load(loc, &__atomic_exchange_old_val, __ATOMIC_ACQUIRE);\n"
  "  else\n"
  "    __atomic_load(loc, &__atomic_exchange_old_val, __ATOMIC_RELAXED);\n"
  "\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_store(loc, val, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_RELEASE)\n"
  "    __atomic_store(loc, val, __ATOMIC_RELEASE);\n"
  "  else\n"
  "    __atomic_store(loc, val, __ATOMIC_RELAXED);\n"
  "\n"
  "  *ret = __atomic_exchange_old_val;\n"
  "\n"
  "  __CPROVER_atomic_end();\n"
  "}\n"
  "\n"
},
{ "__atomic_fetch_add",
  "#line 1 \"<builtin-library-__atomic_fetch_add>\"\n"
  "\n"
  "#ifndef __ATOMIC_RELAXED\n"
  "#  define __ATOMIC_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_CONSUME\n"
  "#  define __ATOMIC_CONSUME 1\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQUIRE\n"
  "#  define __ATOMIC_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELEASE\n"
  "#  define __ATOMIC_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQ_REL\n"
  "#  define __ATOMIC_ACQ_REL 4\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_SEQ_CST\n"
  "#  define __ATOMIC_SEQ_CST 5\n"
  "#endif\n"
  "\n"
  "int __atomic_fetch_add(int* loc, int val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  // load\n"
  "  int __atomic_fetch_load_ret;\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_ACQUIRE)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_ACQUIRE);\n"
  "  else\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_RELAXED);\n"
  "\n"
  "  // calc new value\n"
  "  int __atomic_fetch_store_val;\n"
  "  __atomic_fetch_store_val = __atomic_fetch_load_ret + val;\n"
  "\n"
  "  // and then store\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_RELEASE)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELEASE);\n"
  "  else\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELAXED);\n"
  "\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  return __atomic_fetch_load_ret;\n"
  "}\n"
  "\n"
},
{ "__atomic_fetch_sub",
  "#line 1 \"<builtin-library-__atomic_fetch_sub>\"\n"
  "\n"
  "#ifndef __ATOMIC_RELAXED\n"
  "#  define __ATOMIC_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_CONSUME\n"
  "#  define __ATOMIC_CONSUME 1\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQUIRE\n"
  "#  define __ATOMIC_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELEASE\n"
  "#  define __ATOMIC_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQ_REL\n"
  "#  define __ATOMIC_ACQ_REL 4\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_SEQ_CST\n"
  "#  define __ATOMIC_SEQ_CST 5\n"
  "#endif\n"
  "\n"
  "int __atomic_fetch_sub(int* loc, int val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  // load\n"
  "  int __atomic_fetch_load_ret;\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_ACQUIRE)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_ACQUIRE);\n"
  "  else\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_RELAXED);\n"
  "\n"
  "  // calc new value\n"
  "  int __atomic_fetch_store_val;\n"
  "  __atomic_fetch_store_val = __atomic_fetch_load_ret - val;\n"
  "\n"
  "  // and then store\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_RELEASE)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELEASE);\n"
  "  else\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELAXED);\n"
  "\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  return __atomic_fetch_load_ret;\n"
  "}\n"
  "\n"
},
{ "__atomic_fetch_and",
  "#line 1 \"<builtin-library-__atomic_fetch_and>\"\n"
  "\n"
  "#ifndef __ATOMIC_RELAXED\n"
  "#  define __ATOMIC_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_CONSUME\n"
  "#  define __ATOMIC_CONSUME 1\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQUIRE\n"
  "#  define __ATOMIC_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELEASE\n"
  "#  define __ATOMIC_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQ_REL\n"
  "#  define __ATOMIC_ACQ_REL 4\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_SEQ_CST\n"
  "#  define __ATOMIC_SEQ_CST 5\n"
  "#endif\n"
  "\n"
  "int __atomic_fetch_and(int* loc, int val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  // load\n"
  "  int __atomic_fetch_load_ret;\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_ACQUIRE)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_ACQUIRE);\n"
  "  else\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_RELAXED);\n"
  "\n"
  "  // calc new value\n"
  "  int __atomic_fetch_store_val;\n"
  "  __atomic_fetch_store_val = __atomic_fetch_load_ret & val;\n"
  "\n"
  "  // and then store\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_RELEASE)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELEASE);\n"
  "  else\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELAXED);\n"
  "\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  return __atomic_fetch_load_ret;\n"
  "}\n"
  "\n"
},
{ "__atomic_fetch_or",
  "#line 1 \"<builtin-library-__atomic_fetch_or>\"\n"
  "\n"
  "#ifndef __ATOMIC_RELAXED\n"
  "#  define __ATOMIC_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_CONSUME\n"
  "#  define __ATOMIC_CONSUME 1\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQUIRE\n"
  "#  define __ATOMIC_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELEASE\n"
  "#  define __ATOMIC_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQ_REL\n"
  "#  define __ATOMIC_ACQ_REL 4\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_SEQ_CST\n"
  "#  define __ATOMIC_SEQ_CST 5\n"
  "#endif\n"
  "\n"
  "int __atomic_fetch_or(int* loc, int val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  // load\n"
  "  int __atomic_fetch_load_ret;\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_ACQUIRE)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_ACQUIRE);\n"
  "  else\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_RELAXED);\n"
  "\n"
  "  // calc new value\n"
  "  int __atomic_fetch_store_val;\n"
  "  __atomic_fetch_store_val = __atomic_fetch_load_ret | val;\n"
  "\n"
  "  // and then store\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_RELEASE)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELEASE);\n"
  "  else\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELAXED);\n"
  "\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  return __atomic_fetch_load_ret;\n"
  "}\n"
  "\n"
},
{ "__atomic_fetch_xor",
  "#line 1 \"<builtin-library-__atomic_fetch_xor>\"\n"
  "\n"
  "#ifndef __ATOMIC_RELAXED\n"
  "#  define __ATOMIC_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_CONSUME\n"
  "#  define __ATOMIC_CONSUME 1\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQUIRE\n"
  "#  define __ATOMIC_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_RELEASE\n"
  "#  define __ATOMIC_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_ACQ_REL\n"
  "#  define __ATOMIC_ACQ_REL 4\n"
  "#endif\n"
  "\n"
  "#ifndef __ATOMIC_SEQ_CST\n"
  "#  define __ATOMIC_SEQ_CST 5\n"
  "#endif\n"
  "\n"
  "int __atomic_fetch_xor(int* loc, int val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  // load\n"
  "  int __atomic_fetch_load_ret;\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_ACQUIRE)\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_ACQUIRE);\n"
  "  else\n"
  "    __atomic_load(loc, &__atomic_fetch_load_ret, __ATOMIC_RELAXED);\n"
  "\n"
  "  // calc new value\n"
  "  int __atomic_fetch_store_val;\n"
  "  __atomic_fetch_store_val = __atomic_fetch_load_ret ^ val;\n"
  "\n"
  "  // and then store\n"
  "  if(memorder == __ATOMIC_SEQ_CST)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_SEQ_CST);\n"
  "  else if(memorder == __ATOMIC_ACQ_REL || memorder == __ATOMIC_RELEASE)\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELEASE);\n"
  "  else\n"
  "    __atomic_store(loc, &__atomic_fetch_store_val, __ATOMIC_RELAXED);\n"
  "\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  return __atomic_fetch_load_ret;\n"
  "}\n"
  "\n"
},
{ "__LKMM_LOAD",
  "#line 1 \"<builtin-library-__LKMM_LOAD>\"\n"
  "\n"
  "int __LKMM_LOAD(int* loc, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  return __CPROVER_LKMM_LOAD(loc, memorder);\n"
  "}\n"
  "\n"
},
{ "__LKMM_STORE",
  "#line 1 \"<builtin-library-__LKMM_STORE>\"\n"
  "\n"
  "void __LKMM_STORE(int* loc, int val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_LKMM_STORE(loc, val, memorder);\n"
  "}\n"
  "\n"
},
{ "__LKMM_FENCE",
  "#line 1 \"<builtin-library-__LKMM_FENCE>\"\n"
  "\n"
  "void __LKMM_FENCE(int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "    __CPROVER_fence(\n"
  "      \"WWfence\",\n"
  "      \"RRfence\",\n"
  "      \"RWfence\",\n"
  "      \"WRfence\",\n"
  "      \"WWcumul\",\n"
  "      \"RRcumul\",\n"
  "      \"RWcumul\",\n"
  "      \"WRcumul\");\n"
  "}\n"
  "\n"
},
{ "__LKMM_XCHG",
  "#line 1 \"<builtin-library-__LKMM_XCHG>\"\n"
  "\n"
  "#ifndef __LKMM_RELAXED\n"
  "#define __LKMM_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ONCE\n"
  "#define __LKMM_ONCE 1\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ACQUIRE\n"
  "#define __LKMM_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_RELEASE\n"
  "#define __LKMM_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_MB\n"
  "#define __LKMM_MB 4\n"
  "#endif\n"
  "\n"
  "int __LKMM_XCHG(int* loc, int val, int memorder)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  if(memorder == __LKMM_MB)\n"
  "    __LKMM_FENCE(__LKMM_MB);\n"
  "\n"
  "  __CPROVER_atomic_begin();\n"
  "  int xchg_tmp;\n"
  "  if(memorder == __LKMM_ACQUIRE)\n"
  "    xchg_tmp = __LKMM_LOAD(loc, __LKMM_ACQUIRE);\n"
  "  else\n"
  "    xchg_tmp = __LKMM_LOAD(loc, __LKMM_ONCE);\n"
  "\n"
  "  if(memorder == __LKMM_RELEASE)\n"
  "    __LKMM_STORE(loc, val, __LKMM_RELEASE);\n"
  "  else\n"
  "    __LKMM_STORE(loc, val, __LKMM_ONCE);\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  if(memorder == __LKMM_MB)\n"
  "    __LKMM_FENCE(__LKMM_MB);\n"
  "  \n"
  "  return xchg_tmp;\n"
  "}\n"
  "\n"
},
{ "__LKMM_CMPXCHG",
  "#line 1 \"<builtin-library-__LKMM_CMPXCHG>\"\n"
  "\n"
  "#ifndef __LKMM_RELAXED\n"
  "#define __LKMM_RELAXED 0\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ONCE\n"
  "#define __LKMM_ONCE 1\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ACQUIRE\n"
  "#define __LKMM_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_RELEASE\n"
  "#define __LKMM_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_MB\n"
  "#define __LKMM_MB 4\n"
  "#endif\n"
  "\n"
  "int __LKMM_CMPXCHG(int* loc, int old, int new, int memorder1, int memorder2)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  if(memorder1 == __LKMM_MB)\n"
  "    __LKMM_FENCE(__LKMM_MB);\n"
  "\n"
  "  __CPROVER_atomic_begin();\n"
  "  int xchg_tmp;\n"
  "  if(memorder1 == __LKMM_ACQUIRE)\n"
  "    xchg_tmp = __LKMM_LOAD(loc, __LKMM_ACQUIRE);\n"
  "  else\n"
  "    xchg_tmp = __LKMM_LOAD(loc, __LKMM_ONCE);\n"
  "\n"
  "  if(xchg_tmp == old)\n"
  "  {\n"
  "    if(memorder2 == __LKMM_RELEASE)\n"
  "      __LKMM_STORE(loc, new, __LKMM_RELEASE);\n"
  "    else\n"
  "      __LKMM_STORE(loc, new, __LKMM_ONCE);\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  if(memorder1 == __LKMM_MB)\n"
  "    __LKMM_FENCE(__LKMM_MB);\n"
  "  \n"
  "  return xchg_tmp;\n"
  "}\n"
  "\n"
},
{ "__LKMM_ATOMIC_OP",
  "#line 1 \"<builtin-library-__LKMM_ATOMIC_OP>\"\n"
  "\n"
  "#ifndef __LKMM_ADD\n"
  "#define __LKMM_ADD 0\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_SUB\n"
  "#define __LKMM_SUB 1\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_AND\n"
  "#define __LKMM_AND 2\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_OR\n"
  "#define __LKMM_OR 3\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ONCE\n"
  "#define __LKMM_ONCE 1\n"
  "#endif\n"
  "\n"
  "void __LKMM_ATOMIC_OP(int* loc, int val, int op)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(op == __LKMM_ADD)\n"
  "  {\n"
  "    int fetch_tmp = __LKMM_LOAD(loc, __LKMM_ONCE);\n"
  "    __LKMM_STORE(loc, fetch_tmp + val, __LKMM_ONCE);\n"
  "  }\n"
  "  if(op == __LKMM_SUB)\n"
  "  {\n"
  "    int fetch_tmp = __LKMM_LOAD(loc, __LKMM_ONCE);\n"
  "    __LKMM_STORE(loc, fetch_tmp - val, __LKMM_ONCE);\n"
  "  }\n"
  "  if(op == __LKMM_AND)\n"
  "  {\n"
  "    int fetch_tmp = __LKMM_LOAD(loc, __LKMM_ONCE);\n"
  "    __LKMM_STORE(loc, fetch_tmp & val, __LKMM_ONCE);\n"
  "  }\n"
  "  if(op == __LKMM_OR)\n"
  "  {\n"
  "    int fetch_tmp = __LKMM_LOAD(loc, __LKMM_ONCE);\n"
  "    __LKMM_STORE(loc, fetch_tmp | val, __LKMM_ONCE);\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "}\n"
  "\n"
},
{ "__LKMM_ATOMIC_FETCH_OP",
  "#line 1 \"<builtin-library-__LKMM_ATOMIC_FETCH_OP>\"\n"
  "\n"
  "#ifndef __LKMM_ADD\n"
  "#define __LKMM_ADD 0\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_SUB\n"
  "#define __LKMM_SUB 1\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_AND\n"
  "#define __LKMM_AND 2\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_OR\n"
  "#define __LKMM_OR 3\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ONCE\n"
  "#define __LKMM_ONCE 1\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ACQUIRE\n"
  "#define __LKMM_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_RELEASE\n"
  "#define __LKMM_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_MB\n"
  "#define __LKMM_MB 4\n"
  "#endif\n"
  "\n"
  "int __LKMM_ATOMIC_FETCH_OP(int* loc, int val, int memorder, int op)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  if(memorder == __LKMM_MB)\n"
  "    __LKMM_FENCE(__LKMM_MB);\n"
  "\n"
  "  __CPROVER_atomic_begin();\n"
  "  int fetch_tmp;\n"
  "  if(memorder == __LKMM_ACQUIRE)\n"
  "    fetch_tmp = __LKMM_LOAD(loc, __LKMM_ACQUIRE);\n"
  "  else\n"
  "    fetch_tmp = __LKMM_LOAD(loc, __LKMM_ONCE);\n"
  "\n"
  "  if(op == __LKMM_ADD)\n"
  "  {\n"
  "    if(memorder == __LKMM_RELEASE)\n"
  "      __LKMM_STORE(loc, fetch_tmp + val, __LKMM_RELEASE);\n"
  "    else\n"
  "      __LKMM_STORE(loc, fetch_tmp + val, __LKMM_ONCE);\n"
  "  }\n"
  "  if(op == __LKMM_SUB)\n"
  "  {\n"
  "    if(memorder == __LKMM_RELEASE)\n"
  "      __LKMM_STORE(loc, fetch_tmp - val, __LKMM_RELEASE);\n"
  "    else\n"
  "      __LKMM_STORE(loc, fetch_tmp - val, __LKMM_ONCE);\n"
  "  }\n"
  "  if(op == __LKMM_AND)\n"
  "  {\n"
  "    if(memorder == __LKMM_RELEASE)\n"
  "      __LKMM_STORE(loc, fetch_tmp & val, __LKMM_RELEASE);\n"
  "    else\n"
  "      __LKMM_STORE(loc, fetch_tmp & val, __LKMM_ONCE);\n"
  "  }\n"
  "  if(op == __LKMM_OR)\n"
  "  {\n"
  "    if(memorder == __LKMM_RELEASE)\n"
  "      __LKMM_STORE(loc, fetch_tmp | val, __LKMM_RELEASE);\n"
  "    else\n"
  "      __LKMM_STORE(loc, fetch_tmp | val, __LKMM_ONCE);\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  if(memorder == __LKMM_MB)\n"
  "    __LKMM_FENCE(__LKMM_MB);\n"
  "\n"
  "  return fetch_tmp;\n"
  "}\n"
  "\n"
},
{ "__LKMM_ATOMIC_OP_RETURN",
  "#line 1 \"<builtin-library-__LKMM_ATOMIC_OP_RETURN>\"\n"
  "\n"
  "#ifndef __LKMM_ADD\n"
  "#define __LKMM_ADD 0\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_SUB\n"
  "#define __LKMM_SUB 1\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_AND\n"
  "#define __LKMM_AND 2\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_OR\n"
  "#define __LKMM_OR 3\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ONCE\n"
  "#define __LKMM_ONCE 1\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ACQUIRE\n"
  "#define __LKMM_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_RELEASE\n"
  "#define __LKMM_RELEASE 3\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_MB\n"
  "#define __LKMM_MB 4\n"
  "#endif\n"
  "\n"
  "int __LKMM_ATOMIC_OP_RETURN(int* loc, int val, int memorder, int op)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  if(memorder == __LKMM_MB)\n"
  "    __LKMM_FENCE(__LKMM_MB);\n"
  "\n"
  "  __CPROVER_atomic_begin();\n"
  "  int fetch_tmp;\n"
  "  if(memorder == __LKMM_ACQUIRE)\n"
  "    fetch_tmp = __LKMM_LOAD(loc, __LKMM_ACQUIRE);\n"
  "  else\n"
  "    fetch_tmp = __LKMM_LOAD(loc, __LKMM_ONCE);\n"
  "\n"
  "  if(op == __LKMM_ADD)\n"
  "    fetch_tmp += val;\n"
  "  if(op == __LKMM_SUB)\n"
  "    fetch_tmp -= val;\n"
  "  if(op == __LKMM_AND)\n"
  "    fetch_tmp &= val;\n"
  "  if(op == __LKMM_OR)\n"
  "    fetch_tmp |= val;\n"
  "\n"
  "  if(memorder == __LKMM_RELEASE)\n"
  "    __LKMM_STORE(loc, fetch_tmp, __LKMM_RELEASE);\n"
  "  else\n"
  "    __LKMM_STORE(loc, fetch_tmp, __LKMM_ONCE);\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  if(memorder == __LKMM_MB)\n"
  "    __LKMM_FENCE(__LKMM_MB);\n"
  "\n"
  "  return fetch_tmp;\n"
  "}\n"
  "\n"
},
{ "__LKMM_SPIN_LOCK",
  "#line 1 \"<builtin-library-__LKMM_SPIN_LOCK>\"\n"
  "\n"
  "#ifndef __LKMM_ONCE\n"
  "#define __LKMM_ONCE 1\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_ACQUIRE\n"
  "#define __LKMM_ACQUIRE 2\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_STRUCT_SPINLOCK\n"
  "#define __LKMM_STRUCT_SPINLOCK\n"
  "typedef struct spinlock {\n"
  "    int unused;\n"
  "} spinlock_t;\n"
  "#endif\n"
  "\n"
  "int __LKMM_SPIN_LOCK(spinlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  int lock_status = __LKMM_LOAD((unsigned *)lock, __LKMM_ACQUIRE);\n"
  "  __CPROVER_assume(!lock_status);\n"
  "  __LKMM_STORE((unsigned *)lock, 1, __LKMM_ONCE);\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "__LKMM_SPIN_UNLOCK",
  "#line 1 \"<builtin-library-__LKMM_SPIN_UNLOCK>\"\n"
  "\n"
  "#ifndef __LKMM_STRUCT_SPINLOCK\n"
  "#define __LKMM_STRUCT_SPINLOCK\n"
  "typedef struct spinlock {\n"
  "    int unused;\n"
  "} spinlock_t;\n"
  "#endif\n"
  "\n"
  "#ifndef __LKMM_RELEASE\n"
  "#define __LKMM_RELEASE 3\n"
  "#endif\n"
  "\n"
  "int __LKMM_SPIN_UNLOCK(spinlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __LKMM_STORE((unsigned *)lock, 0, __LKMM_RELEASE);\n"
  "  return 0;\n"
  "}\n"
  "\n"
  "// __SZH_ADD_END__\n"
  "\n"
},
{ "__atomic_always_lock_free",
  "#line 1 \"<builtin-library-__atomic_always_lock_free>\"\n"
  "\n"
  "_Bool __atomic_always_lock_free(__CPROVER_size_t size, void *ptr)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  (void)ptr;\n"
  "  return size <= sizeof(__CPROVER_size_t);\n"
  "}\n"
  "\n"
},
{ "__atomic_is_lock_free",
  "#line 1 \"<builtin-library-__atomic_is_lock_free>\"\n"
  "\n"
  "_Bool __atomic_is_lock_free(__CPROVER_size_t size, void *ptr)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  (void)ptr;\n"
  "  return size <= sizeof(__CPROVER_size_t);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_vec_ext_v4hi",
  "#line 1 \"<builtin-library-__builtin_ia32_vec_ext_v4hi>\"\n"
  "\n"
  "typedef short __gcc_v4hi __attribute__((__vector_size__(8)));\n"
  "\n"
  "short __builtin_ia32_vec_ext_v4hi(__gcc_v4hi vec, int offset)\n"
  "{\n"
  "  return *((short *)&vec + offset);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_vec_ext_v8hi",
  "#line 1 \"<builtin-library-__builtin_ia32_vec_ext_v8hi>\"\n"
  "\n"
  "typedef short __gcc_v8hi __attribute__((__vector_size__(16)));\n"
  "\n"
  "short __builtin_ia32_vec_ext_v8hi(__gcc_v8hi vec, int offset)\n"
  "{\n"
  "  return *((short *)&vec + offset);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_vec_ext_v4si",
  "#line 1 \"<builtin-library-__builtin_ia32_vec_ext_v4si>\"\n"
  "\n"
  "typedef int __gcc_v4si __attribute__((__vector_size__(16)));\n"
  "\n"
  "int __builtin_ia32_vec_ext_v4si(__gcc_v4si vec, int offset)\n"
  "{\n"
  "  return *((int *)&vec + offset);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_vec_ext_v2di",
  "#line 1 \"<builtin-library-__builtin_ia32_vec_ext_v2di>\"\n"
  "\n"
  "typedef long long __gcc_v2di __attribute__((__vector_size__(16)));\n"
  "\n"
  "long long __builtin_ia32_vec_ext_v2di(__gcc_v2di vec, int offset)\n"
  "{\n"
  "  return *((long long *)&vec + offset);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_vec_ext_v16qi",
  "#line 1 \"<builtin-library-__builtin_ia32_vec_ext_v16qi>\"\n"
  "\n"
  "typedef char __gcc_v16qi __attribute__((__vector_size__(16)));\n"
  "\n"
  "int __builtin_ia32_vec_ext_v16qi(__gcc_v16qi vec, int offset)\n"
  "{\n"
  "  return *((char *)&vec + offset);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_vec_ext_v4sf",
  "#line 1 \"<builtin-library-__builtin_ia32_vec_ext_v4sf>\"\n"
  "\n"
  "typedef float __gcc_v4sf __attribute__((__vector_size__(16)));\n"
  "\n"
  "float __builtin_ia32_vec_ext_v4sf(__gcc_v4sf vec, int offset)\n"
  "{\n"
  "  return *((float *)&vec + offset);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_psubsw128",
  "#line 1 \"<builtin-library-__builtin_ia32_psubsw128>\"\n"
  "\n"
  "#ifndef LIBRARY_CHECK\n"
  "typedef short __gcc_v8hi __attribute__((__vector_size__(16)));\n"
  "#else\n"
  "__gcc_v8hi __CPROVER_saturating_minus();\n"
  "#endif\n"
  "\n"
  "__gcc_v8hi __builtin_ia32_psubsw128(__gcc_v8hi a, __gcc_v8hi b)\n"
  "{\n"
  "  return __CPROVER_saturating_minus(a, b);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_psubusw128",
  "#line 1 \"<builtin-library-__builtin_ia32_psubusw128>\"\n"
  "\n"
  "#ifndef LIBRARY_CHECK\n"
  "typedef short __gcc_v8hi __attribute__((__vector_size__(16)));\n"
  "#endif\n"
  "\n"
  "__gcc_v8hi __builtin_ia32_psubusw128(__gcc_v8hi a, __gcc_v8hi b)\n"
  "{\n"
  "  typedef unsigned short v8hi_u __attribute__((__vector_size__(16)));\n"
  "  return (__gcc_v8hi)__CPROVER_saturating_minus((v8hi_u)a, (v8hi_u)b);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_paddsw",
  "#line 1 \"<builtin-library-__builtin_ia32_paddsw>\"\n"
  "\n"
  "#ifndef LIBRARY_CHECK\n"
  "typedef short __gcc_v4hi __attribute__((__vector_size__(8)));\n"
  "#else\n"
  "__gcc_v4hi __CPROVER_saturating_plus();\n"
  "#endif\n"
  "\n"
  "__gcc_v4hi __builtin_ia32_paddsw(__gcc_v4hi a, __gcc_v4hi b)\n"
  "{\n"
  "  return __CPROVER_saturating_plus(a, b);\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_psubsw",
  "#line 1 \"<builtin-library-__builtin_ia32_psubsw>\"\n"
  "\n"
  "#ifndef LIBRARY_CHECK\n"
  "typedef short __gcc_v4hi __attribute__((__vector_size__(8)));\n"
  "#else\n"
  "__gcc_v4hi __CPROVER_saturating_minus_v4hi(__gcc_v4hi, __gcc_v4hi);\n"
  "#  define __CPROVER_saturating_minus __CPROVER_saturating_minus_v4hi\n"
  "#endif\n"
  "\n"
  "__gcc_v4hi __builtin_ia32_psubsw(__gcc_v4hi a, __gcc_v4hi b)\n"
  "{\n"
  "  return __CPROVER_saturating_minus(a, b);\n"
  "}\n"
  "\n"
  "#ifdef LIBRARY_CHECK\n"
  "#  undef __CPROVER_saturating_minus\n"
  "#endif\n"
  "\n"
},
{ "__builtin_ia32_vec_init_v4hi",
  "#line 1 \"<builtin-library-__builtin_ia32_vec_init_v4hi>\"\n"
  "\n"
  "#ifndef LIBRARY_CHECK\n"
  "typedef short __gcc_v4hi __attribute__((__vector_size__(8)));\n"
  "#endif\n"
  "\n"
  "__gcc_v4hi __builtin_ia32_vec_init_v4hi(short e0, short e1, short e2, short e3)\n"
  "{\n"
  "  return (__gcc_v4hi){e0, e1, e2, e3};\n"
  "}\n"
},
{ "getopt",
  "#line 1 \"<builtin-library-getopt>\"\n"
  "\n"
  "extern char *optarg;\n"
  "extern int optind;\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "size_t __VERIFIER_nondet_size_t();\n"
  "\n"
  "int getopt(int argc, char *const argv[], const char *optstring)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result=-1;\n"
  "\n"
  "  if(optind==0)\n"
  "    optind=1;\n"
  "\n"
  "  if(optind>=argc || argv[optind][0]!='-')\n"
  "    return -1;\n"
  "\n"
  "  size_t result_index=__VERIFIER_nondet_size_t();\n"
  "  __CPROVER_assume(\n"
  "    result_index<strlen(optstring) && optstring[result_index]!=':');\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(optstring),\n"
  "    \"getopt zero-termination of 3rd argument\");\n"
  "  #endif\n"
  "\n"
  "  __CPROVER_bool found=__VERIFIER_nondet___CPROVER_bool();\n"
  "  if(found)\n"
  "  {\n"
  "    result=optstring[result_index];\n"
  "    __CPROVER_bool skipped=__VERIFIER_nondet___CPROVER_bool();\n"
  "    if(skipped)\n"
  "      ++optind;\n"
  "  }\n"
  "\n"
  "  if(result!=-1 && optind<argc && optstring[result_index+1]==':')\n"
  "  {\n"
  "    __CPROVER_bool has_no_arg=__VERIFIER_nondet___CPROVER_bool();\n"
  "    if(has_no_arg)\n"
  "    {\n"
  "      optarg=argv[optind];\n"
  "      ++optind;\n"
  "    }\n"
  "    else\n"
  "      optarg=NULL;\n"
  "  }\n"
  "\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "getopt_long",
  "#line 1 \"<builtin-library-getopt_long>\"\n"
  "\n"
  "#ifndef __CPROVER_GETOPT_H_INCLUDED\n"
  "#include <getopt.h>\n"
  "#define __CPROVER_GETOPT_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int getopt_long(\n"
  "  int argc,\n"
  "  char *const argv[],\n"
  "  const char *optstring,\n"
  "  const struct option *longopts,\n"
  "  int *longindex)\n"
  "{\n"
  "  // trigger valid-pointer checks (if enabled), even though we don't\n"
  "  // use the parameter in this model\n"
  "  (void)*longopts;\n"
  "  // avoid unused-parameter warnings when compiling using GCC (for\n"
  "  // internal library syntax checks)\n"
  "  (void)longindex;\n"
  "\n"
  "  return getopt(argc, argv, optstring);\n"
  "}\n"
},
{ "inet_addr",
  "#line 1 \"<builtin-library-inet_addr>\"\n"
  "\n"
  "#ifndef _WIN32\n"
  "\n"
  "#ifndef __CPROVER_INET_H_INCLUDED\n"
  "#include <arpa/inet.h>\n"
  "#define __CPROVER_INET_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "in_addr_t __VERIFIER_nondet_in_addr_t();\n"
  "\n"
  "in_addr_t inet_addr(const char *cp)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(cp),\n"
  "                         \"inet_addr zero-termination of argument\");\n"
  "  #endif\n"
  "  (void)*cp;\n"
  "\n"
  "  in_addr_t result=__VERIFIER_nondet_in_addr_t();\n"
  "  return result;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "inet_aton",
  "#line 1 \"<builtin-library-inet_aton>\"\n"
  "\n"
  "#ifndef _WIN32\n"
  "\n"
  "#ifndef __CPROVER_INET_H_INCLUDED\n"
  "#include <arpa/inet.h>\n"
  "#define __CPROVER_INET_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int inet_aton(const char *cp, struct in_addr *pin)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(cp),\n"
  "                         \"inet_aton zero-termination of name argument\");\n"
  "  #endif\n"
  "  (void)*cp;\n"
  "  (void)*pin;\n"
  "\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "  return result;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "inet_network",
  "#line 1 \"<builtin-library-inet_network>\"\n"
  "\n"
  "#ifndef _WIN32\n"
  "\n"
  "#ifndef __CPROVER_INET_H_INCLUDED\n"
  "#include <arpa/inet.h>\n"
  "#define __CPROVER_INET_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "in_addr_t __VERIFIER_nondet_in_addr_t();\n"
  "\n"
  "in_addr_t inet_network(const char *cp)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(cp),\n"
  "                         \"inet_network zero-termination of name argument\");\n"
  "  #endif\n"
  "  (void)*cp;\n"
  "\n"
  "  in_addr_t result=__VERIFIER_nondet_in_addr_t();\n"
  "  return result;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "htonl",
  "#line 1 \"<builtin-library-htonl>\"\n"
  "\n"
  "#ifndef __CPROVER_STDINT_H_INCLUDED\n"
  "#include <stdint.h>\n"
  "#define __CPROVER_STDINT_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef htonl\n"
  "\n"
  "uint32_t __builtin_bswap32(uint32_t);\n"
  "\n"
  "uint32_t htonl(uint32_t hostlong)\n"
  "{\n"
  "#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n"
  "  return __builtin_bswap32(hostlong);\n"
  "#else\n"
  "  return hostlong;\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "htons",
  "#line 1 \"<builtin-library-htons>\"\n"
  "\n"
  "#ifndef __CPROVER_STDINT_H_INCLUDED\n"
  "#include <stdint.h>\n"
  "#define __CPROVER_STDINT_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef htons\n"
  "\n"
  "uint16_t __builtin_bswap16(uint16_t);\n"
  "\n"
  "uint16_t htons(uint16_t hostshort)\n"
  "{\n"
  "#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n"
  "  return __builtin_bswap16(hostshort);\n"
  "#else\n"
  "  return hostshort;\n"
  "#endif\n"
  "}\n"
  "\n"
  "\n"
},
{ "ntohl",
  "#line 1 \"<builtin-library-ntohl>\"\n"
  "\n"
  "#ifndef __CPROVER_STDINT_H_INCLUDED\n"
  "#include <stdint.h>\n"
  "#define __CPROVER_STDINT_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef ntohl\n"
  "\n"
  "uint32_t __builtin_bswap32(uint32_t);\n"
  "\n"
  "uint32_t ntohl(uint32_t netlong)\n"
  "{\n"
  "#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n"
  "  return __builtin_bswap32(netlong);\n"
  "#else\n"
  "  return netlong;\n"
  "#endif\n"
  "}\n"
  "\n"
  "\n"
},
{ "ntohs",
  "#line 1 \"<builtin-library-ntohs>\"\n"
  "\n"
  "#ifndef __CPROVER_STDINT_H_INCLUDED\n"
  "#include <stdint.h>\n"
  "#define __CPROVER_STDINT_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef ntohs\n"
  "\n"
  "uint16_t __builtin_bswap16(uint16_t);\n"
  "\n"
  "uint16_t ntohs(uint16_t netshort)\n"
  "{\n"
  "#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n"
  "  return __builtin_bswap16(netshort);\n"
  "#else\n"
  "  return netshort;\n"
  "#endif\n"
  "}\n"
  "/* intrin.h is an include file provided by Visual Studio */\n"
  "\n"
},
{ "_InterlockedDecrement",
  "#line 1 \"<builtin-library-_InterlockedDecrement>\"\n"
  "\n"
  "long _InterlockedDecrement(long volatile *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // This function generates a full memory barrier (or fence) to ensure that\n"
  "  // memory operations are completed in order.\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=--(*p);\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchange",
  "#line 1 \"<builtin-library-_InterlockedExchange>\"\n"
  "\n"
  "long _InterlockedExchange(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long old=*p;\n"
  "  *p=v;\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchange16",
  "#line 1 \"<builtin-library-_InterlockedExchange16>\"\n"
  "\n"
  "short _InterlockedExchange16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short old=*p;\n"
  "  *p=v;\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchange8",
  "#line 1 \"<builtin-library-_InterlockedExchange8>\"\n"
  "\n"
  "char _InterlockedExchange8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char old=*p;\n"
  "  *p=v;\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchangeAdd",
  "#line 1 \"<builtin-library-_InterlockedExchangeAdd>\"\n"
  "\n"
  "long _InterlockedExchangeAdd(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchangeAdd16",
  "#line 1 \"<builtin-library-_InterlockedExchangeAdd16>\"\n"
  "\n"
  "short _InterlockedExchangeAdd16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=(*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchangeAdd8",
  "#line 1 \"<builtin-library-_InterlockedExchangeAdd8>\"\n"
  "\n"
  "char _InterlockedExchangeAdd8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char result=(*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedCompareExchange",
  "#line 1 \"<builtin-library-_InterlockedCompareExchange>\"\n"
  "\n"
  "long _InterlockedCompareExchange(long volatile *p, long v1, long v2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long old=(*p);\n"
  "  *p=(old==v2)?v1:old;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedCompareExchange64",
  "#line 1 \"<builtin-library-_InterlockedCompareExchange64>\"\n"
  "\n"
  "long long\n"
  "_InterlockedCompareExchange64(long long volatile *p, long long v1, long long v2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long long old=(*p);\n"
  "  *p=(old==v2)?v1:old;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "__InterlockedIncrement",
  "#line 1 \"<builtin-library-__InterlockedIncrement>\"\n"
  "\n"
  "long _InterlockedIncrement(long volatile *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=++(*p);\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedOr",
  "#line 1 \"<builtin-library-_InterlockedOr>\"\n"
  "\n"
  "long _InterlockedOr(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)|=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedOr8",
  "#line 1 \"<builtin-library-_InterlockedOr8>\"\n"
  "\n"
  "char _InterlockedOr8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char result=(*p)|=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedOr16",
  "#line 1 \"<builtin-library-_InterlockedOr16>\"\n"
  "\n"
  "short _InterlockedOr16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=(*p)|=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedXor",
  "#line 1 \"<builtin-library-_InterlockedXor>\"\n"
  "\n"
  "long _InterlockedXor(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)^=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedXor8",
  "#line 1 \"<builtin-library-_InterlockedXor8>\"\n"
  "\n"
  "char _InterlockedXor8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char result=(*p)^=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedXor16",
  "#line 1 \"<builtin-library-_InterlockedXor16>\"\n"
  "\n"
  "short _InterlockedXor16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=(*p)^=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAnd",
  "#line 1 \"<builtin-library-_InterlockedAnd>\"\n"
  "\n"
  "long _InterlockedAnd(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)&=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAnd8",
  "#line 1 \"<builtin-library-_InterlockedAnd8>\"\n"
  "\n"
  "char _InterlockedAnd8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char result=(*p)&=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAnd16",
  "#line 1 \"<builtin-library-_InterlockedAnd16>\"\n"
  "\n"
  "short _InterlockedAnd16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=(*p)&=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAdd",
  "#line 1 \"<builtin-library-_InterlockedAdd>\"\n"
  "\n"
  "long _InterlockedAdd(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAddLargeStatistic",
  "#line 1 \"<builtin-library-_InterlockedAddLargeStatistic>\"\n"
  "\n"
  "long _InterlockedAddLargeStatistic(long long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // not atomic:\n"
  "  // http://msdn.microsoft.com/en-us/library/yc92ytxy%28v=vs.90%29.aspx\n"
  "  (*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  return v;\n"
  "}\n"
  "\n"
},
{ "_mm_lfence",
  "#line 1 \"<builtin-library-_mm_lfence>\"\n"
  "\n"
  "void _mm_lfence(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "}\n"
  "\n"
},
{ "_mm_mfence",
  "#line 1 \"<builtin-library-_mm_mfence>\"\n"
  "\n"
  "void _mm_mfence(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ "_WriteBarrier",
  "#line 1 \"<builtin-library-_WriteBarrier>\"\n"
  "\n"
  "void _WriteBarrier(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "}\n"
  "\n"
},
{ "_ReadWriteBarrier",
  "#line 1 \"<builtin-library-_ReadWriteBarrier>\"\n"
  "\n"
  "void _ReadWriteBarrier(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ "_ReadBarrier",
  "#line 1 \"<builtin-library-_ReadBarrier>\"\n"
  "\n"
  "void _ReadBarrier(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "}\n"
  "\n"
},
{ "_InterlockedIncrement16",
  "#line 1 \"<builtin-library-_InterlockedIncrement16>\"\n"
  "\n"
  "short _InterlockedIncrement16(short volatile *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=++(*p);\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedDecrement16",
  "#line 1 \"<builtin-library-_InterlockedDecrement16>\"\n"
  "\n"
  "short _InterlockedDecrement16(short volatile *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=--(*p);\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedCompareExchange16",
  "#line 1 \"<builtin-library-_InterlockedCompareExchange16>\"\n"
  "\n"
  "short _InterlockedCompareExchange16(short volatile *p, short v1, short v2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short old=(*p);\n"
  "  *p=(old==v2)?v1:old;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedCompareExchange8",
  "#line 1 \"<builtin-library-_InterlockedCompareExchange8>\"\n"
  "\n"
  "char _InterlockedCompareExchange8(char volatile *p, char v1, char v2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char old=(*p);\n"
  "  *p=(old==v2)?v1:old;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_mm_set_epi32",
  "#line 1 \"<builtin-library-_mm_set_epi32>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m128i _mm_set_epi32(int e3, int e2, int e1, int e0)\n"
  "{\n"
  "  return (__m128i){.m128i_i32 = {e0, e1, e2, e3}};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_setr_epi32",
  "#line 1 \"<builtin-library-_mm_setr_epi32>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m128i _mm_setr_epi32(int e3, int e2, int e1, int e0)\n"
  "{\n"
  "  return (__m128i){.m128i_i32 = {e3, e2, e1, e0}};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_set_epi16",
  "#line 1 \"<builtin-library-_mm_set_epi16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m128i _mm_set_epi16(\n"
  "  short e7,\n"
  "  short e6,\n"
  "  short e5,\n"
  "  short e4,\n"
  "  short e3,\n"
  "  short e2,\n"
  "  short e1,\n"
  "  short e0)\n"
  "{\n"
  "  return (__m128i){.m128i_i16 = {e0, e1, e2, e3, e4, e5, e6, e7}};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_setr_epi16",
  "#line 1 \"<builtin-library-_mm_setr_epi16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m128i _mm_setr_epi16(\n"
  "  short e7,\n"
  "  short e6,\n"
  "  short e5,\n"
  "  short e4,\n"
  "  short e3,\n"
  "  short e2,\n"
  "  short e1,\n"
  "  short e0)\n"
  "{\n"
  "  return (__m128i){.m128i_i16 = {e7, e6, e5, e4, e3, e2, e1, e0}};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_set_pi16",
  "#line 1 \"<builtin-library-_mm_set_pi16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m64 _mm_set_pi16(short e3, short e2, short e1, short e0)\n"
  "{\n"
  "  return (__m64){.m64_i16 = {e0, e1, e2, e3}};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_setr_pi16",
  "#line 1 \"<builtin-library-_mm_setr_pi16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m64 _mm_setr_pi16(short e3, short e2, short e1, short e0)\n"
  "{\n"
  "  return (__m64){.m64_i16 = {e3, e2, e1, e0}};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_extract_epi32",
  "#line 1 \"<builtin-library-_mm_extract_epi32>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "int _mm_extract_epi32(__m128i a, const int imm8)\n"
  "{\n"
  "  return a.m128i_i32[imm8];\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_extract_epi16",
  "#line 1 \"<builtin-library-_mm_extract_epi16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "int _mm_extract_epi16(__m128i a, const int imm8)\n"
  "{\n"
  "  return a.m128i_i16[imm8];\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_extract_pi16",
  "#line 1 \"<builtin-library-_mm_extract_pi16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "int _mm_extract_pi16(__m64 a, const int imm8)\n"
  "{\n"
  "  return a.m64_i16[imm8];\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_adds_epi16",
  "#line 1 \"<builtin-library-_mm_adds_epi16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m128i _mm_adds_epi16(__m128i a, __m128i b)\n"
  "{\n"
  "  return (__m128i){\n"
  "    .m128i_i16 = {\n"
  "      __CPROVER_saturating_plus(a.m128i_i16[0], b.m128i_i16[0]),\n"
  "      __CPROVER_saturating_plus(a.m128i_i16[1], b.m128i_i16[1]),\n"
  "      __CPROVER_saturating_plus(a.m128i_i16[2], b.m128i_i16[2]),\n"
  "      __CPROVER_saturating_plus(a.m128i_i16[3], b.m128i_i16[3]),\n"
  "      __CPROVER_saturating_plus(a.m128i_i16[4], b.m128i_i16[4]),\n"
  "      __CPROVER_saturating_plus(a.m128i_i16[5], b.m128i_i16[5]),\n"
  "      __CPROVER_saturating_plus(a.m128i_i16[6], b.m128i_i16[6]),\n"
  "      __CPROVER_saturating_plus(a.m128i_i16[7], b.m128i_i16[7]),\n"
  "    }};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_subs_epi16",
  "#line 1 \"<builtin-library-_mm_subs_epi16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m128i _mm_subs_epi16(__m128i a, __m128i b)\n"
  "{\n"
  "  return (__m128i){\n"
  "    .m128i_i16 = {\n"
  "      __CPROVER_saturating_minus(a.m128i_i16[0], b.m128i_i16[0]),\n"
  "      __CPROVER_saturating_minus(a.m128i_i16[1], b.m128i_i16[1]),\n"
  "      __CPROVER_saturating_minus(a.m128i_i16[2], b.m128i_i16[2]),\n"
  "      __CPROVER_saturating_minus(a.m128i_i16[3], b.m128i_i16[3]),\n"
  "      __CPROVER_saturating_minus(a.m128i_i16[4], b.m128i_i16[4]),\n"
  "      __CPROVER_saturating_minus(a.m128i_i16[5], b.m128i_i16[5]),\n"
  "      __CPROVER_saturating_minus(a.m128i_i16[6], b.m128i_i16[6]),\n"
  "      __CPROVER_saturating_minus(a.m128i_i16[7], b.m128i_i16[7]),\n"
  "    }};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_adds_epu16",
  "#line 1 \"<builtin-library-_mm_adds_epu16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m128i _mm_adds_epu16(__m128i a, __m128i b)\n"
  "{\n"
  "  return (__m128i){\n"
  "    .m128i_i16 = {\n"
  "      __CPROVER_saturating_plus(a.m128i_u16[0], b.m128i_u16[0]),\n"
  "      __CPROVER_saturating_plus(a.m128i_u16[1], b.m128i_u16[1]),\n"
  "      __CPROVER_saturating_plus(a.m128i_u16[2], b.m128i_u16[2]),\n"
  "      __CPROVER_saturating_plus(a.m128i_u16[3], b.m128i_u16[3]),\n"
  "      __CPROVER_saturating_plus(a.m128i_u16[4], b.m128i_u16[4]),\n"
  "      __CPROVER_saturating_plus(a.m128i_u16[5], b.m128i_u16[5]),\n"
  "      __CPROVER_saturating_plus(a.m128i_u16[6], b.m128i_u16[6]),\n"
  "      __CPROVER_saturating_plus(a.m128i_u16[7], b.m128i_u16[7]),\n"
  "    }};\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "_mm_subs_epu16",
  "#line 1 \"<builtin-library-_mm_subs_epu16>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#  ifndef __CPROVER_INTRIN_H_INCLUDED\n"
  "#    include <intrin.h>\n"
  "#    define __CPROVER_INTRIN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__m128i _mm_subs_epu16(__m128i a, __m128i b)\n"
  "{\n"
  "  return (__m128i){\n"
  "    .m128i_u16 = {\n"
  "      __CPROVER_saturating_minus(a.m128i_u16[0], b.m128i_u16[0]),\n"
  "      __CPROVER_saturating_minus(a.m128i_u16[1], b.m128i_u16[1]),\n"
  "      __CPROVER_saturating_minus(a.m128i_u16[2], b.m128i_u16[2]),\n"
  "      __CPROVER_saturating_minus(a.m128i_u16[3], b.m128i_u16[3]),\n"
  "      __CPROVER_saturating_minus(a.m128i_u16[4], b.m128i_u16[4]),\n"
  "      __CPROVER_saturating_minus(a.m128i_u16[5], b.m128i_u16[5]),\n"
  "      __CPROVER_saturating_minus(a.m128i_u16[6], b.m128i_u16[6]),\n"
  "      __CPROVER_saturating_minus(a.m128i_u16[7], b.m128i_u16[7]),\n"
  "    }};\n"
  "}\n"
  "#endif\n"
},
{ "java::java.io.InputStream.read:()I",
  "#line 1 \"<builtin-library-java::java.io.InputStream.read:()I>\"\n"
  "\n"
  "int __CPROVER_ID \"java::java.io.InputStream.read:()I\" (void *)\n"
  "{\n"
  "  int read_result;\n"
  "  __CPROVER_assume(read_result>=-1 && read_result<=255);\n"
  "  return read_result;\n"
  "}\n"
  "\n"
},
{ "setlocale",
  "#line 1 \"<builtin-library-setlocale>\"\n"
  "\n"
  "#ifndef __CPROVER_LOCALE_H_INCLUDED\n"
  "#include <locale.h>\n"
  "#define __CPROVER_LOCALE_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "char *setlocale(int category, const char *locale)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)category;\n"
  "  (void)*locale;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_event(\"invalidate_pointer\", \"setlocale_result\");\n"
  "  char *setlocale_result;\n"
  "  __CPROVER_set_may(setlocale_result, \"setlocale_result\");\n"
  "  return setlocale_result;\n"
  "  #else\n"
  "  static char setlocale_result[1];\n"
  "  return setlocale_result;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "localeconv",
  "#line 1 \"<builtin-library-localeconv>\"\n"
  "\n"
  "#ifndef __CPROVER_LOCALE_H_INCLUDED\n"
  "#include <locale.h>\n"
  "#define __CPROVER_LOCALE_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "struct lconv *localeconv(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_event(\"invalidate_pointer\", \"localeconv_result\");\n"
  "  struct lconv *localeconv_result;\n"
  "  __CPROVER_set_may(localeconv_result, \"localeconv_result\");\n"
  "  return localeconv_result;\n"
  "  #else\n"
  "  static struct lconv localeconv_result;\n"
  "  return &localeconv_result;\n"
  "  #endif\n"
  "}\n"
},
{ "fabs",
  "#line 1 \"<builtin-library-fabs>\"\n"
  "\n"
  "double fabs(double d)\n"
  "{\n"
  "  return __CPROVER_fabs(d);\n"
  "}\n"
  "\n"
},
{ "fabsl",
  "#line 1 \"<builtin-library-fabsl>\"\n"
  "\n"
  "long double fabsl(long double d)\n"
  "{\n"
  "  return __CPROVER_fabsl(d);\n"
  "}\n"
  "\n"
},
{ "fabsf",
  "#line 1 \"<builtin-library-fabsf>\"\n"
  "\n"
  "float fabsf(float f)\n"
  "{\n"
  "  return __CPROVER_fabsf(f);\n"
  "}\n"
  "\n"
},
{ "__builtin_fabs",
  "#line 1 \"<builtin-library-__builtin_fabs>\"\n"
  "\n"
  "double __builtin_fabs(double d)\n"
  "{\n"
  "  return __CPROVER_fabs(d);\n"
  "}\n"
  "\n"
},
{ "__builtin_fabsl",
  "#line 1 \"<builtin-library-__builtin_fabsl>\"\n"
  "\n"
  "long double __builtin_fabsl(long double d)\n"
  "{\n"
  "  return __CPROVER_fabsl(d);\n"
  "}\n"
  "\n"
},
{ "__builtin_fabsf",
  "#line 1 \"<builtin-library-__builtin_fabsf>\"\n"
  "\n"
  "float __builtin_fabsf(float f)\n"
  "{\n"
  "  return __CPROVER_fabsf(f);\n"
  "}\n"
  "\n"
},
{ "__CPROVER_isgreaterf",
  "#line 1 \"<builtin-library-__CPROVER_isgreaterf>\"\n"
  "\n"
  "int __CPROVER_isgreaterf(float f, float g) { return f > g; }\n"
  "\n"
},
{ "__CPROVER_isgreaterd",
  "#line 1 \"<builtin-library-__CPROVER_isgreaterd>\"\n"
  "\n"
  "int __CPROVER_isgreaterd(double f, double g) { return f > g; }\n"
  "\n"
},
{ "__CPROVER_isgreaterequalf",
  "#line 1 \"<builtin-library-__CPROVER_isgreaterequalf>\"\n"
  "\n"
  "int __CPROVER_isgreaterequalf(float f, float g) { return f >= g; }\n"
  "\n"
},
{ "__CPROVER_isgreaterequald",
  "#line 1 \"<builtin-library-__CPROVER_isgreaterequald>\"\n"
  "\n"
  "int __CPROVER_isgreaterequald(double f, double g) { return f >= g; }\n"
  "\n"
},
{ "__CPROVER_islessf",
  "#line 1 \"<builtin-library-__CPROVER_islessf>\"\n"
  "\n"
  "int __CPROVER_islessf(float f, float g) { return f < g;}\n"
  "\n"
},
{ "__CPROVER_islessd",
  "#line 1 \"<builtin-library-__CPROVER_islessd>\"\n"
  "\n"
  "int __CPROVER_islessd(double f, double g) { return f < g;}\n"
  "\n"
},
{ "__CPROVER_islessequalf",
  "#line 1 \"<builtin-library-__CPROVER_islessequalf>\"\n"
  "\n"
  "int __CPROVER_islessequalf(float f, float g) { return f <= g; }\n"
  "\n"
},
{ "__CPROVER_islessequald",
  "#line 1 \"<builtin-library-__CPROVER_islessequald>\"\n"
  "\n"
  "int __CPROVER_islessequald(double f, double g) { return f <= g; }\n"
  "\n"
},
{ "__CPROVER_islessgreaterf",
  "#line 1 \"<builtin-library-__CPROVER_islessgreaterf>\"\n"
  "\n"
  "int __CPROVER_islessgreaterf(float f, float g) { return (f < g) || (f > g); }\n"
  "\n"
},
{ "__CPROVER_islessgreaterd",
  "#line 1 \"<builtin-library-__CPROVER_islessgreaterd>\"\n"
  "\n"
  "int __CPROVER_islessgreaterd(double f, double g) { return (f < g) || (f > g); }\n"
  "\n"
},
{ "__CPROVER_isunorderedf",
  "#line 1 \"<builtin-library-__CPROVER_isunorderedf>\"\n"
  "\n"
  "int __CPROVER_isunorderedf(float f, float g)\n"
  "{\n"
  "  return __CPROVER_isnanf(f) || __CPROVER_isnanf(g);\n"
  "}\n"
  "\n"
},
{ "__CPROVER_isunorderedd",
  "#line 1 \"<builtin-library-__CPROVER_isunorderedd>\"\n"
  "\n"
  "int __CPROVER_isunorderedd(double f, double g)\n"
  "{\n"
  "  return __CPROVER_isnand(f) || __CPROVER_isnand(g);\n"
  "}\n"
  "\n"
},
{ "isfinite",
  "#line 1 \"<builtin-library-isfinite>\"\n"
  "\n"
  "#undef isfinite\n"
  "\n"
  "int isfinite(double d) { return __CPROVER_isfinited(d); }\n"
  "\n"
},
{ "__finite",
  "#line 1 \"<builtin-library-__finite>\"\n"
  "\n"
  "int __finite(double d) { return __CPROVER_isfinited(d); }\n"
  "\n"
},
{ "__finitef",
  "#line 1 \"<builtin-library-__finitef>\"\n"
  "\n"
  "int __finitef(float f) { return __CPROVER_isfinitef(f); }\n"
  "\n"
},
{ "__finitel",
  "#line 1 \"<builtin-library-__finitel>\"\n"
  "\n"
  "int __finitel(long double ld) { return __CPROVER_isfiniteld(ld); }\n"
  "\n"
},
{ "isinf",
  "#line 1 \"<builtin-library-isinf>\"\n"
  "\n"
  "#undef isinf\n"
  "\n"
  "int isinf(double d)\n"
  "{\n"
  "  return __CPROVER_isinfd(d);\n"
  "}\n"
  "\n"
},
{ "__isinf",
  "#line 1 \"<builtin-library-__isinf>\"\n"
  "\n"
  "int __isinf(double d)\n"
  "{\n"
  "  return __CPROVER_isinfd(d);\n"
  "}\n"
  "\n"
},
{ "isinff",
  "#line 1 \"<builtin-library-isinff>\"\n"
  "\n"
  "int isinff(float f)\n"
  "{\n"
  "  return __CPROVER_isinff(f);\n"
  "}\n"
  "\n"
},
{ "__isinff",
  "#line 1 \"<builtin-library-__isinff>\"\n"
  "\n"
  "int __isinff(float f)\n"
  "{\n"
  "  return __CPROVER_isinff(f);\n"
  "}\n"
  "\n"
},
{ "isinfl",
  "#line 1 \"<builtin-library-isinfl>\"\n"
  "\n"
  "int isinfl(long double ld)\n"
  "{\n"
  "  return __CPROVER_isinfld(ld);\n"
  "}\n"
  "\n"
},
{ "__isinfl",
  "#line 1 \"<builtin-library-__isinfl>\"\n"
  "\n"
  "int __isinfl(long double ld)\n"
  "{\n"
  "  return __CPROVER_isinfld(ld);\n"
  "}\n"
  "\n"
},
{ "isnan",
  "#line 1 \"<builtin-library-isnan>\"\n"
  "\n"
  "#undef isnan\n"
  "\n"
  "int isnan(double d)\n"
  "{\n"
  "  return __CPROVER_isnand(d);\n"
  "}\n"
  "\n"
},
{ "__isnan",
  "#line 1 \"<builtin-library-__isnan>\"\n"
  "\n"
  "int __isnan(double d)\n"
  "{\n"
  "  return __CPROVER_isnand(d);\n"
  "}\n"
  "\n"
},
{ "__isnanf",
  "#line 1 \"<builtin-library-__isnanf>\"\n"
  "\n"
  "int __isnanf(float f)\n"
  "{\n"
  "  return __CPROVER_isnanf(f);\n"
  "}\n"
  "\n"
},
{ "isnanf",
  "#line 1 \"<builtin-library-isnanf>\"\n"
  "\n"
  "int isnanf(float f)\n"
  "{\n"
  "  return __CPROVER_isnanf(f);\n"
  "}\n"
  "\n"
},
{ "isnanl",
  "#line 1 \"<builtin-library-isnanl>\"\n"
  "\n"
  "int isnanl(long double ld)\n"
  "{\n"
  "  return __CPROVER_isnanld(ld);\n"
  "}\n"
  "\n"
},
{ "__isnanl",
  "#line 1 \"<builtin-library-__isnanl>\"\n"
  "\n"
  "int __isnanl(long double ld)\n"
  "{\n"
  "  return __CPROVER_isnanld(ld);\n"
  "}\n"
  "\n"
},
{ "isnormal",
  "#line 1 \"<builtin-library-isnormal>\"\n"
  "\n"
  "#undef isnormal\n"
  "\n"
  "int isnormal(double d)\n"
  "{\n"
  "  return __CPROVER_isnormald(d);\n"
  "}\n"
  "\n"
},
{ "__isnormalf",
  "#line 1 \"<builtin-library-__isnormalf>\"\n"
  "\n"
  "int __isnormalf(float f)\n"
  "{\n"
  "  return __CPROVER_isnormalf(f);\n"
  "}\n"
  "\n"
},
{ "__builtin_inff",
  "#line 1 \"<builtin-library-__builtin_inff>\"\n"
  "\n"
  "float __builtin_inff(void)\n"
  "{\n"
  "  return 1.0f / 0.0f;\n"
  "}\n"
  "\n"
},
{ "__builtin_inf",
  "#line 1 \"<builtin-library-__builtin_inf>\"\n"
  "\n"
  "double __builtin_inf(void)\n"
  "{\n"
  "  return 1.0 / 0.0;\n"
  "}\n"
  "\n"
},
{ "__builtin_infl",
  "#line 1 \"<builtin-library-__builtin_infl>\"\n"
  "\n"
  "long double __builtin_infl(void)\n"
  "{\n"
  "  return 1.0l / 0.0l;\n"
  "}\n"
  "\n"
},
{ "__builtin_isinf",
  "#line 1 \"<builtin-library-__builtin_isinf>\"\n"
  "\n"
  "int __builtin_isinf(double d)\n"
  "{\n"
  "  return __CPROVER_isinfd(d);\n"
  "}\n"
  "\n"
},
{ "__builtin_isinff",
  "#line 1 \"<builtin-library-__builtin_isinff>\"\n"
  "\n"
  "int __builtin_isinff(float f)\n"
  "{\n"
  "  return __CPROVER_isinff(f);\n"
  "}\n"
  "\n"
},
{ "__builtin_isinf",
  "#line 1 \"<builtin-library-__builtin_isinf>\"\n"
  "\n"
  "int __builtin_isinfl(long double ld)\n"
  "{\n"
  "  return __CPROVER_isinfld(ld);\n"
  "}\n"
  "\n"
},
{ "__builtin_isnan",
  "#line 1 \"<builtin-library-__builtin_isnan>\"\n"
  "\n"
  "int __builtin_isnan(double d)\n"
  "{\n"
  "  return __CPROVER_isnand(d);\n"
  "}\n"
  "\n"
},
{ "__builtin_isnanf",
  "#line 1 \"<builtin-library-__builtin_isnanf>\"\n"
  "\n"
  "int __builtin_isnanf(float f)\n"
  "{\n"
  "  return __CPROVER_isnanf(f);\n"
  "}\n"
  "\n"
},
{ "__builtin_huge_valf",
  "#line 1 \"<builtin-library-__builtin_huge_valf>\"\n"
  "\n"
  "float __builtin_huge_valf(void)\n"
  "{\n"
  "  return 1.0f / 0.0f;\n"
  "}\n"
  "\n"
},
{ "__builtin_huge_val",
  "#line 1 \"<builtin-library-__builtin_huge_val>\"\n"
  "\n"
  "double __builtin_huge_val(void)\n"
  "{\n"
  "  return 1.0 / 0.0;\n"
  "}\n"
  "\n"
},
{ "__builtin_huge_vall",
  "#line 1 \"<builtin-library-__builtin_huge_vall>\"\n"
  "\n"
  "long double __builtin_huge_vall(void)\n"
  "{\n"
  "  return 1.0l / 0.0l;\n"
  "}\n"
  "\n"
},
{ "_dsign",
  "#line 1 \"<builtin-library-_dsign>\"\n"
  "\n"
  "int _dsign(double d)\n"
  "{\n"
  "  return __CPROVER_signd(d);\n"
  "}\n"
  "\n"
},
{ "_ldsign",
  "#line 1 \"<builtin-library-_ldsign>\"\n"
  "\n"
  "int _ldsign(long double ld)\n"
  "{\n"
  "  return __CPROVER_signld(ld);\n"
  "}\n"
  "\n"
},
{ "_fdsign",
  "#line 1 \"<builtin-library-_fdsign>\"\n"
  "\n"
  "int _fdsign(float f)\n"
  "{\n"
  "  return __CPROVER_signf(f);\n"
  "}\n"
  "\n"
},
{ "signbit",
  "#line 1 \"<builtin-library-signbit>\"\n"
  "\n"
  "#undef signbit\n"
  "\n"
  "int signbit(double d)\n"
  "{\n"
  "  return __CPROVER_signd(d);\n"
  "}\n"
  "\n"
},
{ "__signbitd",
  "#line 1 \"<builtin-library-__signbitd>\"\n"
  "\n"
  "int __signbitd(double d)\n"
  "{\n"
  "  return __CPROVER_signd(d);\n"
  "}\n"
  "\n"
},
{ "__signbitf",
  "#line 1 \"<builtin-library-__signbitf>\"\n"
  "\n"
  "int __signbitf(float f)\n"
  "{\n"
  "  return __CPROVER_signf(f);\n"
  "}\n"
  "\n"
},
{ "__signbit",
  "#line 1 \"<builtin-library-__signbit>\"\n"
  "\n"
  "int __signbit(double ld)\n"
  "{\n"
  "  return __CPROVER_signld(ld);\n"
  "}\n"
  "\n"
},
{ "_dclass",
  "#line 1 \"<builtin-library-_dclass>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "short _dclass(double d)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "  return __CPROVER_isnand(d)?FP_NAN:\n"
  "         __CPROVER_isinfd(d)?FP_INFINITE:\n"
  "         d==0?FP_ZERO:\n"
  "         __CPROVER_isnormald(d)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "_ldclass",
  "#line 1 \"<builtin-library-_ldclass>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "short _ldclass(long double ld)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "  return __CPROVER_isnanld(ld)?FP_NAN:\n"
  "         __CPROVER_isinfld(ld)?FP_INFINITE:\n"
  "         ld==0?FP_ZERO:\n"
  "         __CPROVER_isnormalld(ld)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "_fdclass",
  "#line 1 \"<builtin-library-_fdclass>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "short _fdclass(float f)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "  return __CPROVER_isnanf(f)?FP_NAN:\n"
  "         __CPROVER_isinff(f)?FP_INFINITE:\n"
  "         f==0?FP_ZERO:\n"
  "         __CPROVER_isnormalf(f)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "__fpclassifyd",
  "#line 1 \"<builtin-library-__fpclassifyd>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __fpclassifyd(double d)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "  return __CPROVER_fpclassify(\n"
  "    FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, d);\n"
  "}\n"
  "\n"
},
{ "__fpclassifyf",
  "#line 1 \"<builtin-library-__fpclassifyf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __fpclassifyf(float f)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "  return __CPROVER_fpclassify(\n"
  "    FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, f);\n"
  "}\n"
  "\n"
},
{ "__fpclassifyl",
  "#line 1 \"<builtin-library-__fpclassifyl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __fpclassifyl(long double f)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "  return __CPROVER_fpclassify(\n"
  "    FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, f);\n"
  "}\n"
  "\n"
},
{ "__fpclassify",
  "#line 1 \"<builtin-library-__fpclassify>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// The variant with long double below is needed for older Macs\n"
  "// only; newer ones use __fpclassifyd.\n"
  "\n"
  "#ifdef __APPLE__\n"
  "int __fpclassify(long double d)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "  return __CPROVER_fpclassify(\n"
  "    FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, d);\n"
  "}\n"
  "#else\n"
  "int __fpclassify(double d)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "  return __CPROVER_fpclassify(\n"
  "    FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, d);\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "sin",
  "#line 1 \"<builtin-library-sin>\"\n"
  "\n"
  "double __VERIFIER_nondet_double();\n"
  "\n"
  "double sin(double x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  double ret=__VERIFIER_nondet_double();\n"
  "\n"
  "  if(__CPROVER_isinfd(x) || __CPROVER_isnand(x))\n"
  "    __CPROVER_assume(__CPROVER_isnand(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==0);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "sinl",
  "#line 1 \"<builtin-library-sinl>\"\n"
  "\n"
  "long double __VERIFIER_nondet_long_double();\n"
  "\n"
  "long double sinl(long double x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  long double ret=__VERIFIER_nondet_long_double();\n"
  "\n"
  "  if(__CPROVER_isinfld(x) || __CPROVER_isnanld(x))\n"
  "    __CPROVER_assume(__CPROVER_isnanld(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==0);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "sinf",
  "#line 1 \"<builtin-library-sinf>\"\n"
  "\n"
  "float __VERIFIER_nondet_float();\n"
  "\n"
  "float sinf(float x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  float ret=__VERIFIER_nondet_float();\n"
  "\n"
  "  if(__CPROVER_isinff(x) || __CPROVER_isnanf(x))\n"
  "    __CPROVER_assume(__CPROVER_isnanf(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==0);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "cos",
  "#line 1 \"<builtin-library-cos>\"\n"
  "\n"
  "double __VERIFIER_nondet_double();\n"
  "\n"
  "double cos(double x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  double ret=__VERIFIER_nondet_double();\n"
  "\n"
  "  if(__CPROVER_isinfd(x) || __CPROVER_isnand(x))\n"
  "    __CPROVER_assume(__CPROVER_isnand(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==1);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "cosl",
  "#line 1 \"<builtin-library-cosl>\"\n"
  "\n"
  "long double __VERIFIER_nondet_long_double();\n"
  "\n"
  "long double cosl(long double x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  long double ret=__VERIFIER_nondet_long_double();\n"
  "\n"
  "  if(__CPROVER_isinfld(x) || __CPROVER_isnanld(x))\n"
  "    __CPROVER_assume(__CPROVER_isnanld(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==1);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "cosf",
  "#line 1 \"<builtin-library-cosf>\"\n"
  "\n"
  "float __VERIFIER_nondet_float();\n"
  "\n"
  "float cosf(float x)\n"
  "{\n"
  "__CPROVER_hide:;\n"
  "  // gross over-approximation\n"
  "  float ret=__VERIFIER_nondet_float();\n"
  "\n"
  "  if(__CPROVER_isinff(x) || __CPROVER_isnanf(x))\n"
  "    __CPROVER_assume(__CPROVER_isnanf(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==1);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "__builtin_nan",
  "#line 1 \"<builtin-library-__builtin_nan>\"\n"
  "\n"
  "double __builtin_nan(const char *str)\n"
  "{\n"
  "  // the 'str' argument is not yet used\n"
  "__CPROVER_hide:;\n"
  "  (void)*str;\n"
  "  return 0.0/0.0;\n"
  "}\n"
  "\n"
},
{ "__builtin_nanf",
  "#line 1 \"<builtin-library-__builtin_nanf>\"\n"
  "\n"
  "float __builtin_nanf(const char *str)\n"
  "{\n"
  "  // the 'str' argument is not yet used\n"
  "__CPROVER_hide:;\n"
  "  (void)*str;\n"
  "  return 0.0f/0.0f;\n"
  "}\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " * The call nan(\"n-char-sequence\") is equivalent to\n"
  " * strtod(\"NAN(n-char-sequence)\", (char**) NULL); the call nan(\"\") is\n"
  " * equivalent to strtod(\"NAN()\", (char**) NULL). If tagp does not\n"
  " * point to an n-char sequence or an empty string, the call is\n"
  " * equivalent to strtod(\"NAN\", (char**) NULL). Calls to nanf and nanl\n"
  " * are equivalent to the corresponding calls to strtof and strtold.\n"
  " *\n"
  " * The nan functions return a quiet NaN, if available, with content\n"
  " * indicated through tagp. If the implementation does not support\n"
  " * quiet NaNs, the functions return zero.\n"
  " */\n"
  "\n"
},
{ "nan",
  "#line 1 \"<builtin-library-nan>\"\n"
  "\n"
  "double nan(const char *str) {\n"
  "  // the 'str' argument is not yet used\n"
  " __CPROVER_hide:;\n"
  "  (void)*str;\n"
  "  return 0.0/0.0;\n"
  "}\n"
  "\n"
},
{ "nanf",
  "#line 1 \"<builtin-library-nanf>\"\n"
  "\n"
  "float nanf(const char *str) {\n"
  "  // the 'str' argument is not yet used\n"
  " __CPROVER_hide:;\n"
  "  (void)*str;\n"
  "  return 0.0f/0.0f;\n"
  "}\n"
  "\n"
},
{ "nanl",
  "#line 1 \"<builtin-library-nanl>\"\n"
  "\n"
  "long double nanl(const char *str) {\n"
  "  // the 'str' argument is not yet used\n"
  " __CPROVER_hide:;\n"
  "  (void)*str;\n"
  "  return 0.0/0.0;\n"
  "}\n"
  "\n"
},
{ "nextUpf",
  "#line 1 \"<builtin-library-nextUpf>\"\n"
  "\n"
  "#ifndef __CPROVER_LIMITS_H_INCLUDED\n"
  "#include <limits.h>\n"
  "#define __CPROVER_LIMITS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "\n"
  "// IEEE_754 2008 althought similar to C's nextafter / nexttowards\n"
  "// Loosely assumes that float is (IEEE-754) binary32\n"
  "\n"
  "union mixf\n"
  "{\n"
  "  float f;\n"
  "  #ifdef LIBRARY_CHECK\n"
  "  int bv;\n"
  "  #else\n"
  "  __CPROVER_bitvector[CHAR_BIT * sizeof(float)] bv;\n"
  "  #endif\n"
  "};\n"
  "\n"
  "float nextUpf(float f)\n"
  "{\n"
  "__CPROVER_hide:;\n"
  "  if (__CPROVER_isnanf(f))\n"
  "    return 0.0f/0.0f;  // NaN\n"
  "  else if (f == 0.0f)\n"
  "    return 0x1p-149f;\n"
  "  else if (f > 0.0f)\n"
  "  {\n"
  "    if (__CPROVER_isinff(f))\n"
  "      return f;\n"
  "\n"
  "    union mixf m;\n"
  "    m.f = f;\n"
  "    ++m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(f < 0.0f);\n"
  "\n"
  "    union mixf m;\n"
  "    m.f = f;\n"
  "    --m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "nextUp",
  "#line 1 \"<builtin-library-nextUp>\"\n"
  "\n"
  "#ifndef __CPROVER_LIMITS_H_INCLUDED\n"
  "#include <limits.h>\n"
  "#define __CPROVER_LIMITS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "\n"
  "// IEEE_754 2008 althought similar to C's nextafter / nexttowards\n"
  "// Loosely assumes that double is (IEEE-754) binary64\n"
  "\n"
  "union mixd\n"
  "{\n"
  "  double f;\n"
  "  #ifdef LIBRARY_CHECK\n"
  "  long long int bv;\n"
  "  #else\n"
  "  __CPROVER_bitvector[CHAR_BIT * sizeof(double)] bv;\n"
  "  #endif\n"
  "};\n"
  "\n"
  "double nextUp(double d)\n"
  "{\n"
  "__CPROVER_hide:;\n"
  "  if (__CPROVER_isnand(d))\n"
  "    return 0.0/0.0;  // NaN\n"
  "  else if (d == 0.0)\n"
  "    return 0x1.0p-1074;\n"
  "  else if (d > 0.0)\n"
  "  {\n"
  "    if (__CPROVER_isinfd(d))\n"
  "      return d;\n"
  "\n"
  "    union mixd m;\n"
  "    m.f = d;\n"
  "    ++m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(d < 0.0);\n"
  "\n"
  "    union mixd m;\n"
  "    m.f = d;\n"
  "    --m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "}\n"
  "\n"
  "\n"
},
{ "nextUpl",
  "#line 1 \"<builtin-library-nextUpl>\"\n"
  "\n"
  "#ifndef __CPROVER_LIMITS_H_INCLUDED\n"
  "#include <limits.h>\n"
  "#define __CPROVER_LIMITS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// IEEE_754 2008 althought similar to C's nextafter / nexttowards\n"
  "\n"
  "union mixl\n"
  "{\n"
  "  long double f;\n"
  "  #ifdef LIBRARY_CHECK\n"
  "  long long int bv;\n"
  "  #else\n"
  "  __CPROVER_bitvector[CHAR_BIT * sizeof(long double)] bv;\n"
  "  #endif\n"
  "};\n"
  "\n"
  "long double nextUpl(long double d)\n"
  "{\n"
  "__CPROVER_hide:;\n"
  "  if(__CPROVER_isnanld(d))\n"
  "    return 0.0/0.0;  // NaN\n"
  "  else if (d == 0.0)\n"
  "  {\n"
  "    union mixl m;\n"
  "    m.bv = 0x1;\n"
  "    return m.f;\n"
  "  }\n"
  "  else if (d > 0.0)\n"
  "  {\n"
  "    if(__CPROVER_isinfld(d))\n"
  "      return d;\n"
  "\n"
  "    union mixl m;\n"
  "    m.f = d;\n"
  "    ++m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(d < 0.0);\n"
  "\n"
  "    union mixl m;\n"
  "    m.f = d;\n"
  "    --m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "  \n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "\n"
},
{ "sqrtf",
  "#line 1 \"<builtin-library-sqrtf>\"\n"
  "\n"
  "/* This code is *WRONG* in some circumstances, specifically:\n"
  " *\n"
  " *   1. If run with a rounding mode other than RNE the\n"
  " *      answer will be out by one or two ULP.  This could be fixed\n"
  " *      with careful choice of round mode for the multiplications.\n"
  " *\n"
  " *   2. Subnormals have the unusual property that there are\n"
  " *      multiple numbers that square to give them.  I.E. if\n"
  " *      f is subnormal then there are multiple f1 != f2 such that\n"
  " *      f1 * f1 == f == f2 * f2.  This code will return *a*\n"
  " *      square root of a subnormal input but not necessarily *the*\n"
  " *      square root (i.e. the real value of the square root rounded).\n"
  " */\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float nextUpf(float f);\n"
  "\n"
  "float __VERIFIER_nondet_float();\n"
  "\n"
  "float sqrtf(float f)\n"
  "{\n"
  " __CPROVER_hide:;\n"
  "\n"
  "  if ( f < 0.0f )\n"
  "    return 0.0f/0.0f; // NaN\n"
  "  else if (__CPROVER_isinff(f) ||   // +Inf only\n"
  "           f == 0.0f          ||   // Includes -0\n"
  "           __CPROVER_isnanf(f))\n"
  "    return f;\n"
  "  else if (__CPROVER_isnormalf(f))\n"
  "  {\n"
  "    float lower=__VERIFIER_nondet_float();\n"
  "    __CPROVER_assume(lower > 0.0f);\n"
  "    __CPROVER_assume(__CPROVER_isnormalf(lower));\n"
  "    // Tighter bounds can be given but are dependent on the\n"
  "    // number of exponent and significand bits.  Thus they are\n"
  "    // given implicitly...\n"
  "\n"
  "    float lowerSquare = lower * lower;\n"
  "    __CPROVER_assume(__CPROVER_isnormalf(lowerSquare));\n"
  "\n"
  "    float upper = nextUpf(lower);\n"
  "    float upperSquare = upper * upper;  // Might be +Inf\n"
  "\n"
  "    // Restrict these to bound f and thus compute the possible\n"
  "    // values for the square root.  Note that the lower bound\n"
  "    // can be equal, this is important to catch edge cases such as\n"
  "    // 0x1.fffffep+127f and relies on the smallest normal number\n"
  "    // being a perfect square (which it will be for any sensible\n"
  "    // bit width).\n"
  "    __CPROVER_assume(lowerSquare <= f);\n"
  "    __CPROVER_assume(f < upperSquare);\n"
  "\n"
  "    // Select between them to work out which to return\n"
  "    switch(fegetround())\n"
  "    {\n"
  "    case FE_TONEAREST :\n"
  "      return (f - lowerSquare < upperSquare - f) ? lower : upper; break;\n"
  "    case FE_UPWARD :\n"
  "      return (f - lowerSquare == 0.0f) ? lower : upper; break;\n"
  "    case FE_DOWNWARD : // Fall through\n"
  "    case FE_TOWARDZERO :\n"
  "      return (f - lowerSquare == 0.0f) ? lower : upper; break;\n"
  "    default:;\n"
  "      return __VERIFIER_nondet_float();\n"
  "    }\n"
  "\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(fpclassify(f) == FP_SUBNORMAL);\n"
  "    //assert(f > 0.0f);\n"
  "\n"
  "    // With respect to the algebra of floating point number\n"
  "    // all subnormals seem to be perfect squares, thus ...\n"
  "\n"
  "    float root=__VERIFIER_nondet_float();\n"
  "    __CPROVER_assume(root >= 0.0f);\n"
  "\n"
  "    __CPROVER_assume(root * root == f);\n"
  "\n"
  "    return root;\n"
  "  }\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "\n"
},
{ "sqrt",
  "#line 1 \"<builtin-library-sqrt>\"\n"
  "\n"
  "/* The same caveats as sqrtf apply */\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double nextUp(double d);\n"
  "\n"
  "double __VERIFIER_nondet_double();\n"
  "\n"
  "double sqrt(double d)\n"
  "{\n"
  " __CPROVER_hide:;\n"
  "\n"
  "  if ( d < 0.0 )\n"
  "    return 0.0/0.0; // NaN\n"
  "  else if (__CPROVER_isinfd(d) ||   // +Inf only\n"
  "           d == 0.0            ||   // Includes -0\n"
  "           __CPROVER_isnand(d))\n"
  "    return d;\n"
  "  else if (__CPROVER_isnormald(d))\n"
  "  {\n"
  "    double lower=__VERIFIER_nondet_double();\n"
  "    __CPROVER_assume(lower > 0.0);\n"
  "    __CPROVER_assume(__CPROVER_isnormald(lower));\n"
  "\n"
  "    double lowerSquare = lower * lower;\n"
  "    __CPROVER_assume(__CPROVER_isnormald(lowerSquare));\n"
  "\n"
  "    double upper = nextUp(lower);\n"
  "    double upperSquare = upper * upper;  // Might be +Inf\n"
  "\n"
  "    __CPROVER_assume(lowerSquare <= d);\n"
  "    __CPROVER_assume(d < upperSquare);\n"
  "\n"
  "    switch(fegetround())\n"
  "    {\n"
  "    case FE_TONEAREST:\n"
  "      return (d - lowerSquare < upperSquare - d) ? lower : upper; break;\n"
  "    case FE_UPWARD:\n"
  "      return (d - lowerSquare == 0.0f) ? lower : upper; break;\n"
  "    case FE_DOWNWARD: // Fall through\n"
  "    case FE_TOWARDZERO:\n"
  "      return (d - lowerSquare == 0.0) ? lower : upper; break;\n"
  "    default:;\n"
  "      return __VERIFIER_nondet_double();\n"
  "    }\n"
  "\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(fpclassify(d) == FP_SUBNORMAL);\n"
  "    //assert(d > 0.0);\n"
  "\n"
  "    double root=__VERIFIER_nondet_double();\n"
  "    __CPROVER_assume(root >= 0.0);\n"
  "\n"
  "    __CPROVER_assume(root * root == d);\n"
  "\n"
  "    return root;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "sqrtl",
  "#line 1 \"<builtin-library-sqrtl>\"\n"
  "\n"
  "/* The same caveats as sqrtf apply */\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double nextUpl(long double d);\n"
  "\n"
  "long double __VERIFIER_nondet_long_double();\n"
  "\n"
  "long double sqrtl(long double d)\n"
  "{\n"
  " __CPROVER_hide:;\n"
  "\n"
  "  if(d < 0.0l)\n"
  "    return 0.0l/0.0l; // NaN\n"
  "  else if (__CPROVER_isinfld(d) ||   // +Inf only\n"
  "           d == 0.0l            ||   // Includes -0\n"
  "           __CPROVER_isnanld(d))\n"
  "    return d;\n"
  "  else if (__CPROVER_isnormalld(d))\n"
  "  {\n"
  "    long double lower=__VERIFIER_nondet_long_double();\n"
  "    __CPROVER_assume(lower > 0.0l);\n"
  "    __CPROVER_assume(__CPROVER_isnormalld(lower));\n"
  "\n"
  "    long double lowerSquare = lower * lower;\n"
  "    __CPROVER_assume(__CPROVER_isnormalld(lowerSquare));\n"
  "\n"
  "    long double upper = nextUpl(lower);\n"
  "    long double upperSquare = upper * upper;  // Might be +Inf\n"
  "\n"
  "    __CPROVER_assume(lowerSquare <= d);\n"
  "    __CPROVER_assume(d < upperSquare);\n"
  "\n"
  "    switch(fegetround())\n"
  "    {\n"
  "    case FE_TONEAREST:\n"
  "      return (d - lowerSquare < upperSquare - d) ? lower : upper; break;\n"
  "    case FE_UPWARD:\n"
  "      return (d - lowerSquare == 0.0l) ? lower : upper; break;\n"
  "    case FE_DOWNWARD: // Fall through\n"
  "    case FE_TOWARDZERO:\n"
  "      return (d - lowerSquare == 0.0l) ? lower : upper; break;\n"
  "    default:;\n"
  "      return __VERIFIER_nondet_long_double();\n"
  "    }\n"
  "\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(fpclassify(d) == FP_SUBNORMAL);\n"
  "    //assert(d > 0.0l);\n"
  "\n"
  "    long double root=__VERIFIER_nondet_long_double();\n"
  "    __CPROVER_assume(root >= 0.0l);\n"
  "\n"
  "    __CPROVER_assume(root * root == d);\n"
  "\n"
  "    return root;\n"
  "  }\n"
  "}\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " * The fmax functions determine the maximum numeric value of their\n"
  " * arguments. 242)\n"
  " *\n"
  " * 242) NaN arguments are treated as missing data: if one argument is\n"
  " * a NaN and the other numeric, then the fmax functions choose the\n"
  " * numeric value. See F.10.9.2.\n"
  " *\n"
  " * - If just one argument is a NaN, the fmax functions return the other\n"
  " *   argument (if both arguments are NaNs, the functions return a NaN).\n"
  " * - The returned value is exact and is independent of the current\n"
  " *   rounding direction mode.\n"
  " * - The body of the fmax function might be 374)\n"
  " *       { return (isgreaterequal(x, y) || isnan(y)) ? x : y; }\n"
  " *\n"
  " * 374) Ideally, fmax would be sensitive to the sign of zero, for\n"
  " * example fmax(-0.0, +0.0) would return +0; however, implementation\n"
  " * in software might be impractical.\n"
  " */\n"
  "\n"
},
{ "fmax",
  "#line 1 \"<builtin-library-fmax>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// TODO : Should call a __CPROVER_function so that it can be converted to SMT-LIB\n"
  "double fmax(double f, double g) { return ((f >= g) || isnan(g)) ? f : g; }\n"
  "\n"
},
{ "fmaxf",
  "#line 1 \"<builtin-library-fmaxf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// TODO : Should call a __CPROVER_function so that it can be converted to SMT-LIB\n"
  "float fmaxf(float f, float g) { return ((f >= g) || isnan(g)) ? f : g; }\n"
  "\n"
},
{ "fmaxl",
  "#line 1 \"<builtin-library-fmaxl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// TODO : Should call a __CPROVER_function so that it can be converted to SMT-LIB\n"
  "long double fmaxl(long double f, long double g) { return ((f >= g) || isnan(g)) ? f : g; }\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " * The fmin functions determine the minimum numeric value of their\n"
  " * arguments.243)\n"
  " *\n"
  " * 243) The fmin functions are analogous to the fmax functions in\n"
  " * their treatment of NaNs.\n"
  " *\n"
  " * - The fmin functions are analogous to the fmax functions (see F.10.9.2).\n"
  " * - The returned value is exact and is independent of the current\n"
  " *   rounding direction mode.\n"
  " */\n"
  "\n"
},
{ "fmin",
  "#line 1 \"<builtin-library-fmin>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  " \n"
  "// TODO : Should call a __CPROVER_function so that it can be converted to SMT-LIB\n"
  "double fmin(double f, double g) { return ((f <= g) || isnan(g)) ? f : g; }\n"
  "\n"
},
{ "fminf",
  "#line 1 \"<builtin-library-fminf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// TODO : Should call a __CPROVER_function so that it can be converted to SMT-LIB \n"
  "float fminf(float f, float g) { return ((f <= g) || isnan(g)) ? f : g; }\n"
  "\n"
},
{ "fminl",
  "#line 1 \"<builtin-library-fminl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// TODO : Should call a __CPROVER_function so that it can be converted to SMT-LIB \n"
  "long double fminl(long double f, long double g) { return ((f <= g) || isnan(g)) ? f : g; }\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " * The fdim functions determine the positive difference between their\n"
  " * arguments:\n"
  " *     x - y if x > y\n"
  " *     +0    if x <= y\n"
  " * A range error may occur.\n"
  " */\n"
  "\n"
},
{ "fdim",
  "#line 1 \"<builtin-library-fdim>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double fdim(double f, double g) { return ((f > g) ? f - g : +0.0); }\n"
  "\n"
  "\n"
},
{ "fdimf",
  "#line 1 \"<builtin-library-fdimf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float fdimf(float f, float g) { return ((f > g) ? f - g : +0.0f); }\n"
  "\n"
  "\n"
},
{ "fdiml",
  "#line 1 \"<builtin-library-fdiml>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double fdiml(long double f, long double g) { return ((f > g) ? f - g : +0.0); }\n"
  "\n"
  "\n"
  "\n"
},
{ "__sort_of_CPROVER_round_to_integral",
  "#line 1 \"<builtin-library-__sort_of_CPROVER_round_to_integral>\"\n"
  "// TODO : Should be a real __CPROVER function to convert to SMT-LIB\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d)\n"
  "{\n"
  "  double magicConst = 0x1.0p+52;\n"
  "  double return_value;\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(rounding_mode);\n"
  "  \n"
  "  if (fabs(d) >= magicConst || d == 0.0)\n"
  "  {\n"
  "    return_value = d;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    if (!signbit(d)) {\n"
  "      double tmp = d + magicConst;\n"
  "      return_value = tmp - magicConst;\n"
  "    } else {\n"
  "      double tmp = d - magicConst;\n"
  "      return_value = tmp + magicConst;    \n"
  "    }\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "__sort_of_CPROVER_round_to_integralf",
  "#line 1 \"<builtin-library-__sort_of_CPROVER_round_to_integralf>\"\n"
  "// TODO : Should be a real __CPROVER function to convert to SMT-LIB\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d)\n"
  "{\n"
  "  float magicConst = 0x1.0p+23f;  // 23 is significant\n"
  "  float return_value;\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(rounding_mode);\n"
  "  \n"
  "  if (fabsf(d) >= magicConst || d == 0.0)\n"
  "  {\n"
  "    return_value = d;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    if (!signbit(d)) {\n"
  "      float tmp = d + magicConst;\n"
  "      return_value = tmp - magicConst;    \n"
  "    } else {\n"
  "      float tmp = d - magicConst;\n"
  "      return_value = tmp + magicConst;    \n"
  "    }\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
  "\n"
},
{ "__sort_of_CPROVER_round_to_integrall",
  "#line 1 \"<builtin-library-__sort_of_CPROVER_round_to_integrall>\"\n"
  "// TODO : Should be a real __CPROVER function to convert to SMT-LIB\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d)\n"
  "{\n"
  "  long double magicConst = 0x1.0p+64;\n"
  "  long double return_value;\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(rounding_mode);\n"
  "  \n"
  "  if (fabsl(d) >= magicConst || d == 0.0)\n"
  "  {\n"
  "    return_value = d;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    if (!signbit(d)) {\n"
  "      long double tmp = d + magicConst;\n"
  "      return_value = tmp - magicConst;    \n"
  "    } else {\n"
  "      long double tmp = d - magicConst;\n"
  "      return_value = tmp + magicConst;    \n"
  "    }\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The ceil functions compute the smallest integer value not less than\n"
  " * x.\n"
  " */\n"
  "\n"
},
{ "ceil",
  "#line 1 \"<builtin-library-ceil>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "double ceil(double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integral(FE_UPWARD, x);\n"
  "}\n"
  "\n"
},
{ "ceilf",
  "#line 1 \"<builtin-library-ceilf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "float ceilf(float x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integralf(FE_UPWARD, x);\n"
  "}\n"
  "\n"
  "\n"
},
{ "ceill",
  "#line 1 \"<builtin-library-ceill>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long double ceill(long double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integrall(FE_UPWARD, x);\n"
  "}\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The floor functions compute the largest integer value not greater than x.\n"
  " */\n"
  "\n"
},
{ "floor",
  "#line 1 \"<builtin-library-floor>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "double floor(double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integral(FE_DOWNWARD, x);\n"
  "}\n"
  "\n"
},
{ "floorf",
  "#line 1 \"<builtin-library-floorf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "float floorf(float x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integralf(FE_DOWNWARD, x);\n"
  "}\n"
  "\n"
  "\n"
},
{ "floorl",
  "#line 1 \"<builtin-library-floorl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long double floorl(long double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integrall(FE_DOWNWARD, x);\n"
  "}\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The trunc functions round their argument to the integer value, in\n"
  " * floating format, nearest to but no larger in magnitude than the argument.\n"
  " */\n"
  "\n"
},
{ "trunc",
  "#line 1 \"<builtin-library-trunc>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "double trunc(double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integral(FE_TOWARDZERO, x);\n"
  "}\n"
  "\n"
},
{ "truncf",
  "#line 1 \"<builtin-library-truncf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "float truncf(float x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integralf(FE_TOWARDZERO, x);\n"
  "}\n"
  "\n"
  "\n"
},
{ "truncl",
  "#line 1 \"<builtin-library-truncl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long double truncl(long double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integrall(FE_TOWARDZERO, x);\n"
  "}\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The round functions round their argument to the integer value, in\n"
  " * floating format, nearest to but no larger in magnitude than the argument.\n"
  " */\n"
  "\n"
},
{ "round",
  "#line 1 \"<builtin-library-round>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "double round(double x)\n"
  "{\n"
  "  // Tempting but RNE not RNA\n"
  "  // return __sort_of_CPROVER_round_to_integral(FE_TONEAREST, x);\n"
  "\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  double xp;\n"
  "  if (x > 0.0) {\n"
  "    xp = x + 0.5;\n"
  "  } else if (x < 0.0) {\n"
  "    xp = x - 0.5;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  return __sort_of_CPROVER_round_to_integral(FE_TOWARDZERO, xp);\n"
  "}\n"
  "\n"
},
{ "roundf",
  "#line 1 \"<builtin-library-roundf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "float roundf(float x)\n"
  "{\n"
  "  // Tempting but RNE not RNA\n"
  "  // return __sort_of_CPROVER_round_to_integralf(FE_TONEAREST, x);\n"
  "\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  float xp;\n"
  "  if (x > 0.0f) {\n"
  "    xp = x + 0.5f;\n"
  "  } else if (x < 0.0f) {\n"
  "    xp = x - 0.5f;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  return __sort_of_CPROVER_round_to_integralf(FE_TOWARDZERO, xp);\n"
  "}\n"
  "\n"
  "\n"
},
{ "roundl",
  "#line 1 \"<builtin-library-roundl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long double roundl(long double x)\n"
  "{\n"
  "  // Tempting but RNE not RNA\n"
  "  // return __sort_of_CPROVER_round_to_integrall(FE_TONEAREST, x);\n"
  "\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  long double xp;\n"
  "  if (x > 0.0) {\n"
  "    xp = x + 0.5;\n"
  "  } else if (x < 0.0) {\n"
  "    xp = x - 0.5;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  return __sort_of_CPROVER_round_to_integrall(FE_TOWARDZERO, xp);\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The nearbyint functions round their argument to an integer value in\n"
  " * floating-point format, using the current rounding direction and\n"
  " * without raising the inexact floating-point exception.\n"
  " */\n"
  "\n"
},
{ "nearbyint",
  "#line 1 \"<builtin-library-nearbyint>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "double nearbyint(double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integral(fegetround(), x);\n"
  "}\n"
  "\n"
},
{ "nearbyintf",
  "#line 1 \"<builtin-library-nearbyintf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "float nearbyintf(float x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integralf(fegetround(), x);\n"
  "}\n"
  "\n"
  "\n"
},
{ "nearbyintl",
  "#line 1 \"<builtin-library-nearbyintl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long double nearbyintl(long double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integrall(fegetround(), x);\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The rint functions differ from the nearbyint functions (7.12.9.3)\n"
  " * only in that the rint functions may raise the inexact\n"
  " * floating-point exception if the result differs in value from the argument.\n"
  " */\n"
  "\n"
},
{ "rint",
  "#line 1 \"<builtin-library-rint>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "double rint(double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integral(fegetround(), x);\n"
  "}\n"
  "\n"
},
{ "rintf",
  "#line 1 \"<builtin-library-rintf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "float rintf(float x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integralf(fegetround(), x);\n"
  "}\n"
  "\n"
},
{ "rintl",
  "#line 1 \"<builtin-library-rintl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long double rintl(long double x)\n"
  "{\n"
  "  return __sort_of_CPROVER_round_to_integrall(fegetround(), x);\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The lrint and llrint functions round their argument to the nearest\n"
  " * integer value, rounding according to the current rounding\n"
  " * direction. If the rounded value is outside the range of the return\n"
  " * type, the numeric result is unspecified and a domain error or range\n"
  " * error may occur.\n"
  " */\n"
  "\n"
},
{ "lrint",
  "#line 1 \"<builtin-library-lrint>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "long int lrint(double x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT\n"
  "  double rti = __sort_of_CPROVER_round_to_integral(fegetround(), x);\n"
  "  return (long int)rti;\n"
  "}\n"
  "\n"
},
{ "lrintf",
  "#line 1 \"<builtin-library-lrintf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "long int lrintf(float x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT\n"
  "  float rti = __sort_of_CPROVER_round_to_integralf(fegetround(), x);\n"
  "  return (long int)rti;\n"
  "}\n"
  "\n"
  "\n"
},
{ "lrintl",
  "#line 1 \"<builtin-library-lrintl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long int lrintl(long double x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT\n"
  "  long double rti = __sort_of_CPROVER_round_to_integrall(fegetround(), x);\n"
  "  return (long int)rti;\n"
  "}\n"
  "\n"
  "\n"
},
{ "llrint",
  "#line 1 \"<builtin-library-llrint>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "long long int llrint(double x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT\n"
  "  double rti = __sort_of_CPROVER_round_to_integral(fegetround(), x);\n"
  "  return (long long int)rti;\n"
  "}\n"
  "\n"
},
{ "llrintf",
  "#line 1 \"<builtin-library-llrintf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "long long int llrintf(float x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT\n"
  "  float rti = __sort_of_CPROVER_round_to_integralf(fegetround(), x);\n"
  "  return (long long int)rti;\n"
  "}\n"
  "\n"
  "\n"
},
{ "llrintl",
  "#line 1 \"<builtin-library-llrintl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long long int llrintl(long double x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT\n"
  "  long double rti = __sort_of_CPROVER_round_to_integrall(fegetround(), x);\n"
  "  return (long long int)rti;\n"
  "}\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The lround and llround functions round their argument to the\n"
  " * nearest integer value, rounding halfway cases away from zero,\n"
  " * regardless of the current rounding direction. If the rounded value\n"
  " * is outside the range of the return type, the numeric result is\n"
  " * unspecified and a domain error or range error may occur.\n"
  " */\n"
  "\n"
},
{ "lround",
  "#line 1 \"<builtin-library-lround>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "long int lround(double x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT, plus should use RNA\n"
  "\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  double xp;\n"
  "  if (x > 0.0) {\n"
  "    xp = x + 0.5;\n"
  "  } else if (x < 0.0) {\n"
  "    xp = x - 0.5;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  double rti = __sort_of_CPROVER_round_to_integral(FE_TOWARDZERO, xp);\n"
  "  return (long int)rti;\n"
  "}\n"
  "\n"
},
{ "lroundf",
  "#line 1 \"<builtin-library-lroundf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "long int lroundf(float x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT, plus should use RNA\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  float xp;\n"
  "  if (x > 0.0f) {\n"
  "    xp = x + 0.5f;\n"
  "  } else if (x < 0.0f) {\n"
  "    xp = x - 0.5f;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  float rti = __sort_of_CPROVER_round_to_integralf(FE_TOWARDZERO, xp);\n"
  "  return (long int)rti;\n"
  "}\n"
  "\n"
  "\n"
},
{ "lroundl",
  "#line 1 \"<builtin-library-lroundl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long int lroundl(long double x)\n"
  "{\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT, plus should use RNA\n"
  "  long double xp;\n"
  "  if (x > 0.0) {\n"
  "    xp = x + 0.5;\n"
  "  } else if (x < 0.0) {\n"
  "    xp = x - 0.5;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  long double rti = __sort_of_CPROVER_round_to_integrall(FE_TOWARDZERO, xp);\n"
  "  return (long int)rti;\n"
  "}\n"
  "\n"
  "\n"
},
{ "llround",
  "#line 1 \"<builtin-library-llround>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "long long int llround(double x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT, plus should use RNA\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  double xp;\n"
  "  if (x > 0.0) {\n"
  "    xp = x + 0.5;\n"
  "  } else if (x < 0.0) {\n"
  "    xp = x - 0.5;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  double rti = __sort_of_CPROVER_round_to_integral(FE_TOWARDZERO, xp);\n"
  "  return (long long int)rti;\n"
  "}\n"
  "\n"
},
{ "llroundf",
  "#line 1 \"<builtin-library-llroundf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "long long int llroundf(float x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT, plus should use RNA\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  float xp;\n"
  "  if (x > 0.0f) {\n"
  "    xp = x + 0.5f;\n"
  "  } else if (x < 0.0f) {\n"
  "    xp = x - 0.5f;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  float rti = __sort_of_CPROVER_round_to_integralf(FE_TOWARDZERO, xp);\n"
  "  return (long long int)rti;\n"
  "}\n"
  "\n"
  "\n"
},
{ "llroundl",
  "#line 1 \"<builtin-library-llroundl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long long int llroundl(long double x)\n"
  "{\n"
  "  // TODO : should be an all-in-one __CPROVER function to allow\n"
  "  // conversion to SMT, plus should use RNA\n"
  "  int saved_rounding_mode = fegetround();\n"
  "  fesetround(FE_TOWARDZERO);\n"
  "\n"
  "  long double xp;\n"
  "  if (x > 0.0) {\n"
  "    xp = x + 0.5;\n"
  "  } else if (x < 0.0) {\n"
  "    xp = x - 0.5;\n"
  "  } else {\n"
  "    xp = x;\n"
  "  }\n"
  "\n"
  "  fesetround(saved_rounding_mode);\n"
  "  \n"
  "  long double rti = __sort_of_CPROVER_round_to_integrall(FE_TOWARDZERO, xp);\n"
  "  return (long long int)rti;\n"
  "}\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The modf functions break the argument value into integral and\n"
  " * fractional parts, each of which has the same type and sign as the\n"
  " * argument. They store the integral part (in floating-point format)\n"
  " * in the object pointed to by iptr.\n"
  " */\n"
  "\n"
},
{ "modf",
  "#line 1 \"<builtin-library-modf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "\n"
  "double modf(double x, double *iptr)\n"
  "{\n"
  "  *iptr = __sort_of_CPROVER_round_to_integral(FE_TOWARDZERO, x);\n"
  "  return (x - *iptr);\n"
  "}\n"
  "\n"
},
{ "modff",
  "#line 1 \"<builtin-library-modff>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "  float modff(float x, float *iptr)\n"
  "{\n"
  "  *iptr = __sort_of_CPROVER_round_to_integralf(FE_TOWARDZERO, x);\n"
  "  return (x - *iptr);\n"
  "}\n"
  "\n"
  "\n"
},
{ "modfl",
  "#line 1 \"<builtin-library-modfl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "  long double modfl(long double x, long double *iptr)\n"
  "{\n"
  "  *iptr = __sort_of_CPROVER_round_to_integralf(FE_TOWARDZERO, x);\n"
  "  return (x - *iptr);\n"
  "}\n"
  "\n"
  "\n"
  "\n"
},
{ "__sort_of_CPROVER_remainder",
  "#line 1 \"<builtin-library-__sort_of_CPROVER_remainder>\"\n"
  "// TODO : Should be a real __CPROVER function to convert to SMT-LIB\n"
  "double __sort_of_CPROVER_round_to_integral (int rounding_mode, double d);\n"
  "  \n"
  "double __sort_of_CPROVER_remainder (int rounding_mode, double x, double y)\n"
  "{\n"
  "  if (x == 0.0 || __CPROVER_isinfd(y))\n"
  "    return x;\n"
  "\n"
  "  // Extended precision helps... a bit...\n"
  "  long double div = x/y;\n"
  "  long double n = __sort_of_CPROVER_round_to_integral(rounding_mode,div);\n"
  "  long double res = (-y * n) + x;   // TODO : FMA would be an improvement\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "__sort_of_CPROVER_remainderf",
  "#line 1 \"<builtin-library-__sort_of_CPROVER_remainderf>\"\n"
  "// TODO : Should be a real __CPROVER function to convert to SMT-LIB\n"
  "\n"
  "float __sort_of_CPROVER_round_to_integralf (int rounding_mode, float d);\n"
  "\n"
  "float __sort_of_CPROVER_remainderf (int rounding_mode, float x, float y)\n"
  "{\n"
  "  if (x == 0.0f || __CPROVER_isinff(y))\n"
  "    return x;\n"
  "\n"
  "  // Extended precision helps... a bit...\n"
  "  long double div = x/y;\n"
  "  long double n = __sort_of_CPROVER_round_to_integral(rounding_mode,div);\n"
  "  long double res = (-y * n) + x;   // TODO : FMA would be an improvement\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "__sort_of_CPROVER_remainderl",
  "#line 1 \"<builtin-library-__sort_of_CPROVER_remainderl>\"\n"
  "// TODO : Should be a real __CPROVER function to convert to SMT-LIB\n"
  "\n"
  "long double __sort_of_CPROVER_round_to_integrall (int rounding_mode, long double d);\n"
  "\n"
  "long double __sort_of_CPROVER_remainderl (int rounding_mode, long double x, long double y)\n"
  "{\n"
  "  if (x == 0.0 || __CPROVER_isinfld(y))\n"
  "    return x;\n"
  "\n"
  "  // Extended precision helps... a bit...\n"
  "  long double div = x/y;\n"
  "  long double n = __sort_of_CPROVER_round_to_integral(rounding_mode,div);\n"
  "  long double res = (-y * n) + x;   // TODO : FMA would be an improvement\n"
  "  return res;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The fmod functions return the value x - ny, for some\n"
  " * integer n such that, if y is nonzero, the result has the same sign\n"
  " * as x and magnitude less than the magnitude of y. If y is zero,\n"
  " * whether a domain error occurs or the fmod functions return zero is\n"
  " * implementation-defined.\n"
  " */\n"
  "\n"
},
{ "fmod",
  "#line 1 \"<builtin-library-fmod>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double fmod(double x, double y)\n"
  "{\n"
  "  return __CPROVER_fmod(x, y);\n"
  "}\n"
  "\n"
},
{ "fmodf",
  "#line 1 \"<builtin-library-fmodf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float fmodf(float x, float y)\n"
  "{\n"
  "  return __CPROVER_fmodf(x, y);\n"
  "}\n"
  "\n"
},
{ "fmodl",
  "#line 1 \"<builtin-library-fmodl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double fmodl(long double x, long double y)\n"
  "{\n"
  "  return __CPROVER_fmodl(x, y);\n"
  "}\n"
  "\n"
  "/* ISO 9899:2011\n"
  " *\n"
  " * The remainder functions compute the remainder x REM y required by\n"
  " * IEC 60559.239)\n"
  " *\n"
  " * 239) \"When y != 0, the remainder r = x REM y is defined regardless\n"
  " *      of the rounding mode by the  mathematical relation r = x - n\n"
  " *      y, where n is the integer nearest the exact value of x/y;\n"
  " *      whenever | n -  x/y | = 1/2, then n is even. If r = 0, its\n"
  " *      sign shall be that of x.\" This definition is applicable for\n"
  " *      all implementations.\n"
  " */\n"
  "\n"
},
{ "remainder",
  "#line 1 \"<builtin-library-remainder>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double __sort_of_CPROVER_remainder (int rounding_mode, double x, double y);\n"
  "\n"
  "double remainder(double x, double y) { return __sort_of_CPROVER_remainder(FE_TONEAREST, x, y); }\n"
  "\n"
  "\n"
},
{ "remainderf",
  "#line 1 \"<builtin-library-remainderf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float __sort_of_CPROVER_remainderf (int rounding_mode, float x, float y);\n"
  "\n"
  "float remainderf(float x, float y) { return __sort_of_CPROVER_remainderf(FE_TONEAREST, x, y); }\n"
  "\n"
  "\n"
},
{ "remainderl",
  "#line 1 \"<builtin-library-remainderl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double __sort_of_CPROVER_remainderl (int rounding_mode, long double x, long double y);\n"
  "\n"
  "long double remainderl(long double x, long double y) { return __sort_of_CPROVER_remainderl(FE_TONEAREST, x, y); }\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "/* ISO 9899:2011\n"
  " * The copysign functions produce a value with the magnitude of x and\n"
  " * the sign of y. They produce a NaN (with the sign of y) if x is a\n"
  " * NaN. On implementations that represent a signed zero but do not\n"
  " * treat negative zero consistently in arithmetic operations, the\n"
  " * copysign functions regard the sign of zero as positive.\n"
  " */\n"
  "\n"
},
{ "copysign",
  "#line 1 \"<builtin-library-copysign>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double fabs (double d);\n"
  "\n"
  "double copysign(double x, double y)\n"
  "{\n"
  "  double abs = fabs(x);\n"
  "  return (signbit(y)) ? -abs : abs;\n"
  "}\n"
  "\n"
},
{ "copysignf",
  "#line 1 \"<builtin-library-copysignf>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float fabsf (float d);\n"
  "\n"
  "float copysignf(float x, float y)\n"
  "{\n"
  "  float abs = fabs(x);\n"
  "  return (signbit(y)) ? -abs : abs;\n"
  "}\n"
  "\n"
},
{ "copysignl",
  "#line 1 \"<builtin-library-copysignl>\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double fabsl (long double d);\n"
  "\n"
  "long double copysignl(long double x, long double y)\n"
  "{\n"
  "  long double abs = fabsl(x);\n"
  "  return (signbit(y)) ? -abs : abs;\n"
  "}\n"
},
{ "mmap",
  "#line 1 \"<builtin-library-mmap>\"\n"
  "\n"
  "#ifndef _WIN32\n"
  "\n"
  "#  ifndef __CPROVER_SYS_MMAN_H_INCLUDED\n"
  "#    include <sys/mman.h>\n"
  "#    define __CPROVER_SYS_MMAN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "#  ifndef MAP_FIXED\n"
  "#    define MAP_FIXED 0\n"
  "#  endif\n"
  "\n"
  "#  ifndef MAP_ANONYMOUS\n"
  "#    define MAP_ANONYMOUS 0\n"
  "#  endif\n"
  "\n"
  "#  ifndef MAP_UNINITIALIZED\n"
  "#    define MAP_UNINITIALIZED 0\n"
  "#  endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "void *mmap(\n"
  "  void *addr,\n"
  "  __CPROVER_size_t length,\n"
  "  int prot,\n"
  "  int flags,\n"
  "  int fd,\n"
  "  off_t offset)\n"
  "{\n"
  "  (void)prot;\n"
  "  (void)fd;\n"
  "  (void)offset;\n"
  "\n"
  "  if(\n"
  "    addr == 0 ||\n"
  "    (__VERIFIER_nondet___CPROVER_bool() && (flags & MAP_FIXED) == 0))\n"
  "  {\n"
  "    if(flags & MAP_ANONYMOUS && (flags & MAP_UNINITIALIZED) == 0)\n"
  "      return __CPROVER_allocate(length, 1);\n"
  "    else\n"
  "      return __CPROVER_allocate(length, 0);\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_allocated_memory((__CPROVER_size_t)addr, length);\n"
  "    return addr;\n"
  "  }\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_mmap",
  "#line 1 \"<builtin-library-_mmap>\"\n"
  "\n"
  "#ifndef _WIN32\n"
  "\n"
  "#  ifndef __CPROVER_SYS_MMAN_H_INCLUDED\n"
  "#    include <sys/mman.h>\n"
  "#    define __CPROVER_SYS_MMAN_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "#  ifndef MAP_FIXED\n"
  "#    define MAP_FIXED 0\n"
  "#  endif\n"
  "\n"
  "#  ifndef MAP_ANONYMOUS\n"
  "#    define MAP_ANONYMOUS 0\n"
  "#  endif\n"
  "\n"
  "#  ifndef MAP_UNINITIALIZED\n"
  "#    define MAP_UNINITIALIZED 0\n"
  "#  endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "void *_mmap(\n"
  "  void *addr,\n"
  "  __CPROVER_size_t length,\n"
  "  int prot,\n"
  "  int flags,\n"
  "  int fd,\n"
  "  off_t offset)\n"
  "{\n"
  "  (void)prot;\n"
  "  (void)fd;\n"
  "  (void)offset;\n"
  "\n"
  "  if(\n"
  "    addr == 0 ||\n"
  "    (__VERIFIER_nondet___CPROVER_bool() && (flags & MAP_FIXED) == 0))\n"
  "  {\n"
  "    if(flags & MAP_ANONYMOUS && (flags & MAP_UNINITIALIZED) == 0)\n"
  "      return __CPROVER_allocate(length, 1);\n"
  "    else\n"
  "      return __CPROVER_allocate(length, 0);\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_allocated_memory((__CPROVER_size_t)addr, length);\n"
  "    return addr;\n"
  "  }\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "munmap",
  "#line 1 \"<builtin-library-munmap>\"\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "int munmap(void *addr, __CPROVER_size_t length)\n"
  "{\n"
  "  (void)length;\n"
  "\n"
  "  __CPROVER_deallocate(addr);\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "_munmap",
  "#line 1 \"<builtin-library-_munmap>\"\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "int _munmap(void *addr, __CPROVER_size_t length)\n"
  "{\n"
  "  (void)length;\n"
  "\n"
  "  __CPROVER_deallocate(addr);\n"
  "\n"
  "  return 0;\n"
  "}\n"
},
{ "gethostbyname",
  "#line 1 \"<builtin-library-gethostbyname>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#include <windows.h>\n"
  "#else\n"
  "#include <netdb.h>\n"
  "#endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "struct hostent *gethostbyname(const char *name)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(name),\n"
  "                         \"gethostbyname zero-termination of name argument\");\n"
  "  #endif\n"
  "  (void)*name;\n"
  "\n"
  "  __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "  if(error) return 0;\n"
  "\n"
  "  // quite restrictive, as will alias between calls\n"
  "  static struct hostent result;\n"
  "\n"
  "  // we whould be filling in the fields of this\n"
  "  return &result;\n"
  "}\n"
  "\n"
},
{ "gethostbyaddr",
  "#line 1 \"<builtin-library-gethostbyaddr>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#include <windows.h>\n"
  "#else\n"
  "#include <netdb.h>\n"
  "#endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*(char*)addr;\n"
  "  (void)len;\n"
  "  (void)type;\n"
  "\n"
  "  __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "  if(error) return 0;\n"
  "\n"
  "  // quite restrictive, as will alias between calls\n"
  "  static struct hostent result;\n"
  "\n"
  "  // we whould be filling in the fields of this\n"
  "  return &result;\n"
  "}\n"
  "\n"
},
{ "gethostent",
  "#line 1 \"<builtin-library-gethostent>\"\n"
  "\n"
  "// There does not appear to be a Windows variant of gethostent\n"
  "#include <netdb.h>\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "struct hostent *gethostent(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "  if(error) return 0;\n"
  "\n"
  "  // quite restrictive, as will alias between calls\n"
  "  static struct hostent result;\n"
  "\n"
  "  // we whould be filling in the fields of this\n"
  "  return &result;\n"
  "}\n"
},
{ "_beginthread",
  "#line 1 \"<builtin-library-_beginthread>\"\n"
  "\n"
  "__CPROVER_size_t __VERIFIER_nondet___CPROVER_size_t();\n"
  "\n"
  "__CPROVER_size_t _beginthread(\n"
  "  void (*start_address)(void *),\n"
  "  unsigned stack_size,\n"
  "  void *arglist)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_ASYNC_1: start_address(arglist);\n"
  "  (void)stack_size;\n"
  "  __CPROVER_size_t handle=__VERIFIER_nondet___CPROVER_size_t();\n"
  "  return handle;\n"
  "}\n"
  "\n"
},
{ "_beginthreadex",
  "#line 1 \"<builtin-library-_beginthreadex>\"\n"
  "\n"
  "__CPROVER_size_t __VERIFIER_nondet___CPROVER_size_t();\n"
  "\n"
  "__CPROVER_size_t _beginthreadex(\n"
  "   void *security,\n"
  "   unsigned stack_size,\n"
  "   unsigned (*start_address )(void *),\n"
  "   void *arglist,\n"
  "   unsigned initflag,\n"
  "   unsigned *thrdaddr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_ASYNC_1: start_address(arglist);\n"
  "  if(security)\n"
  "    (void)*(char*)security;\n"
  "  (void)stack_size;\n"
  "  (void)initflag;\n"
  "  (void)*thrdaddr;\n"
  "  __CPROVER_size_t handle=__VERIFIER_nondet___CPROVER_size_t();\n"
  "  return handle;\n"
  "}\n"
},
{ "pthread_mutexattr_settype",
  "#line 1 \"<builtin-library-pthread_mutexattr_settype>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  (void)attr;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  if(type==PTHREAD_MUTEX_RECURSIVE)\n"
  "    __CPROVER_set_must(attr, \"mutexattr-recursive\");\n"
  "  #else\n"
  "  (void)type;\n"
  "  #endif\n"
  "\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "pthread_cancel",
  "#line 1 \"<builtin-library-pthread_cancel>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int pthread_cancel(pthread_t thread)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  (void)thread;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(&thread, \"pthread-id\"),\n"
  "                   \"pthread_cancel must be given valid thread ID\");\n"
  "  #endif\n"
  "\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_init",
  "#line 1 \"<builtin-library-pthread_mutex_init>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_mutex_t_defined\n"
  "#define __CPROVER_mutex_t_defined\n"
  "#if defined __CYGWIN__ || defined __MINGW32__ || defined _WIN32\n"
  "// on Windows, the mutexes are integers already\n"
  "typedef pthread_mutex_t __CPROVER_mutex_t;\n"
  "#else\n"
  "typedef signed char __CPROVER_mutex_t;\n"
  "#endif\n"
  "#endif\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "void pthread_mutex_cleanup(void *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_assert(\n"
  "    __CPROVER_get_must(p, \"mutex-destroyed\"),\n"
  "    \"mutex must be destroyed\");\n"
  "}\n"
  "#endif\n"
  "\n"
  "int pthread_mutex_init(\n"
  "  pthread_mutex_t *mutex,\n"
  "  const pthread_mutexattr_t *mutexattr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  *((__CPROVER_mutex_t *)mutex)=0;\n"
  "  if(mutexattr!=0) (void)*mutexattr;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_cleanup(mutex, pthread_mutex_cleanup);\n"
  "  __CPROVER_set_must(mutex, \"mutex-init\");\n"
  "  __CPROVER_clear_may(mutex, \"mutex-destroyed\");\n"
  "  if(__CPROVER_get_must(mutexattr, \"mutexattr-recursive\"))\n"
  "    __CPROVER_set_must(mutex, \"mutex-recursive\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_lock",
  "#line 1 \"<builtin-library-pthread_mutex_lock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_mutex_t_defined\n"
  "#define __CPROVER_mutex_t_defined\n"
  "#if defined __CYGWIN__ || defined __MINGW32__ || defined _WIN32\n"
  "// on Windows, the mutexes are integers already\n"
  "typedef pthread_mutex_t __CPROVER_mutex_t;\n"
  "#else\n"
  "typedef signed char __CPROVER_mutex_t;\n"
  "#endif\n"
  "#endif\n"
  "\n"
  "int pthread_mutex_lock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(mutex, \"mutex-init\"),\n"
  "                   \"mutex must be initialized\");\n"
  "\n"
  "  __CPROVER_assert(!__CPROVER_get_may(mutex, \"mutex-destroyed\"),\n"
  "                   \"mutex must not be destroyed\");\n"
  "\n"
  "  __CPROVER_assert(__CPROVER_get_must(mutex, \"mutex-recursive\") ||\n"
  "                   !__CPROVER_get_may(mutex, \"mutex-locked\"),\n"
  "                   \"attempt to lock non-recurisive locked mutex\");\n"
  "\n"
  "  __CPROVER_set_must(mutex, \"mutex-locked\");\n"
  "  __CPROVER_set_may(mutex, \"mutex-locked\");\n"
  "\n"
  "  __CPROVER_assert(*((__CPROVER_mutex_t *)mutex)!=-1,\n"
  "    \"mutex not initialised or destroyed\");\n"
  "  #else\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assume(!*((__CPROVER_mutex_t *)mutex));\n"
  "  *((__CPROVER_mutex_t *)mutex)=1;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  #endif\n"
  "\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_trylock",
  "#line 1 \"<builtin-library-pthread_mutex_trylock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_mutex_t_defined\n"
  "#define __CPROVER_mutex_t_defined\n"
  "#if defined __CYGWIN__ || defined __MINGW32__ || defined _WIN32\n"
  "// on Windows, the mutexes are integers already\n"
  "typedef pthread_mutex_t __CPROVER_mutex_t;\n"
  "#else\n"
  "typedef signed char __CPROVER_mutex_t;\n"
  "#endif\n"
  "#endif\n"
  "\n"
  "int pthread_mutex_trylock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(mutex, \"mutex-init\"),\n"
  "                   \"mutex must be initialized\");\n"
  "\n"
  "  __CPROVER_assert(*((__CPROVER_mutex_t *)mutex)!=-1,\n"
  "    \"mutex not initialised or destroyed\");\n"
  "  #endif\n"
  "\n"
  "  if(*((__CPROVER_mutex_t *)mutex)==1)\n"
  "  {\n"
  "    // failed\n"
  "    return_value=16;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    // ok\n"
  "    return_value=0;\n"
  "    *((__CPROVER_mutex_t *)mutex)=1;\n"
  "  }\n"
  "\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_unlock",
  "#line 1 \"<builtin-library-pthread_mutex_unlock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_mutex_t_defined\n"
  "#define __CPROVER_mutex_t_defined\n"
  "#if defined __CYGWIN__ || defined __MINGW32__ || defined _WIN32\n"
  "// on Windows, the mutexes are integers already\n"
  "typedef pthread_mutex_t __CPROVER_mutex_t;\n"
  "#else\n"
  "typedef signed char __CPROVER_mutex_t;\n"
  "#endif\n"
  "#endif\n"
  "\n"
  "int pthread_mutex_unlock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(mutex, \"mutex-init\"),\n"
  "                   \"mutex must be initialized\");\n"
  "\n"
  "  __CPROVER_assert(__CPROVER_get_must(mutex, \"mutex-locked\"),\n"
  "                   \"mutex must be locked\");\n"
  "\n"
  "  __CPROVER_assert(!__CPROVER_get_may(mutex, \"mutex-destroyed\"),\n"
  "                   \"mutex must not be destroyed\");\n"
  "\n"
  "  __CPROVER_clear_may(mutex, \"mutex-locked\");\n"
  "\n"
  "  #else\n"
  "\n"
  "  // the fence must be before the unlock\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                    \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  __CPROVER_atomic_begin();\n"
  "  // __CPROVER_assert(*((__CPROVER_mutex_t *)mutex)==1,\n"
  "  //   \"must hold lock upon unlock\");\n"
  "  *((__CPROVER_mutex_t *)mutex)=0;\n"
  "  __CPROVER_atomic_end();\n"
  "  #endif\n"
  "\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_destroy",
  "#line 1 \"<builtin-library-pthread_mutex_destroy>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_mutex_t_defined\n"
  "#define __CPROVER_mutex_t_defined\n"
  "#if defined __CYGWIN__ || defined __MINGW32__ || defined _WIN32\n"
  "// on Windows, the mutexes are integers already\n"
  "typedef pthread_mutex_t __CPROVER_mutex_t;\n"
  "#else\n"
  "typedef signed char __CPROVER_mutex_t;\n"
  "#endif\n"
  "#endif\n"
  "\n"
  "int pthread_mutex_destroy(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(mutex, \"mutex-init\"),\n"
  "                   \"mutex must be initialized\");\n"
  "\n"
  "  __CPROVER_assert(!__CPROVER_get_may(mutex, \"mutex-locked\"),\n"
  "                   \"mutex must not be locked\");\n"
  "\n"
  "  __CPROVER_assert(!__CPROVER_get_may(mutex, \"mutex-destroyed\"),\n"
  "                   \"mutex must not be destroyed\");\n"
  "\n"
  "  __CPROVER_set_must(mutex, \"mutex-destroyed\");\n"
  "  __CPROVER_set_may(mutex, \"mutex-destroyed\");\n"
  "  #else\n"
  "\n"
  "  // __CPROVER_assert(*((__CPROVER_mutex_t *)mutex)==0,\n"
  "  //   \"lock held upon destroy\");\n"
  "  *((__CPROVER_mutex_t *)mutex)=-1;\n"
  "\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_exit",
  "#line 1 \"<builtin-library-pthread_exit>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_bool __CPROVER_threads_exited[];\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_thread_id;\n"
  "\n"
  "extern __CPROVER_thread_local const void *__CPROVER_thread_keys[];\n"
  "extern __CPROVER_thread_local void (*__CPROVER_thread_key_dtors[])(void *);\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_next_thread_key;\n"
  "\n"
  "void pthread_exit(void *value_ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if(value_ptr!=0) (void)*(char*)value_ptr;\n"
  "#if 0\n"
  "  // Destructor support is disabled as it is too expensive due to its extensive\n"
  "  // use of shared variables.\n"
  "  for(unsigned long i = 0; i < __CPROVER_next_thread_key; ++i)\n"
  "  {\n"
  "    const void *key = __CPROVER_thread_keys[i];\n"
  "    __CPROVER_thread_keys[i] = 0;\n"
  "    if(__CPROVER_thread_key_dtors[i] && key)\n"
  "      __CPROVER_thread_key_dtors[i](key);\n"
  "  }\n"
  "#endif\n"
  "  __CPROVER_threads_exited[__CPROVER_thread_id]=1;\n"
  "  __CPROVER_assume(0);\n"
  "#ifdef LIBRARY_CHECK\n"
  "  __builtin_unreachable();\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "pthread_join",
  "#line 1 \"<builtin-library-pthread_join>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_bool __CPROVER_threads_exited[];\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_thread_id;\n"
  "extern unsigned long __CPROVER_next_thread_id;\n"
  "\n"
  "int pthread_join(pthread_t thread, void **value_ptr)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(\n"
  "    __CPROVER_get_must(&thread, \"pthread-id\"),\n"
  "    \"pthread_join must be given valid thread ID\");\n"
  "#endif\n"
  "\n"
  "  if((unsigned long)thread>__CPROVER_next_thread_id) return ESRCH;\n"
  "  if((unsigned long)thread==__CPROVER_thread_id) return EDEADLK;\n"
  "  if(value_ptr!=0) (void)**(char**)value_ptr;\n"
  "  __CPROVER_assume(__CPROVER_threads_exited[(unsigned long)thread]);\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "_pthread_join",
  "#line 1 \"<builtin-library-_pthread_join>\"\n"
  "\n"
  "// This is for Apple\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifdef __APPLE__\n"
  "extern __CPROVER_bool __CPROVER_threads_exited[];\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_thread_id;\n"
  "extern unsigned long __CPROVER_next_thread_id;\n"
  "\n"
  "int _pthread_join(pthread_t thread, void **value_ptr)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(\n"
  "    __CPROVER_get_must(&thread, \"pthread-id\"),\n"
  "    \"pthread_join must be given valid thread ID\");\n"
  "#endif\n"
  "\n"
  "  if((unsigned long)thread>__CPROVER_next_thread_id) return ESRCH;\n"
  "  if((unsigned long)thread==__CPROVER_thread_id) return EDEADLK;\n"
  "  if(value_ptr!=0) (void)**(char**)value_ptr;\n"
  "  __CPROVER_assume(__CPROVER_threads_exited[(unsigned long)thread]);\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_rwlock_destroy",
  "#line 1 \"<builtin-library-pthread_rwlock_destroy>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int pthread_rwlock_destroy(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_assert(*((signed char *)lock)==0,\n"
  "    \"rwlock held upon destroy\");\n"
  "  *((signed char *)lock)=-1;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_set_must(lock, \"rwlock_destroyed\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_init",
  "#line 1 \"<builtin-library-pthread_rwlock_init>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "void pthread_rwlock_cleanup(void *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_assert(__CPROVER_get_must(p, \"rwlock_destroyed\"),\n"
  "                   \"rwlock must be destroyed\");\n"
  "}\n"
  "#endif\n"
  "\n"
  "int pthread_rwlock_init(\n"
  "  pthread_rwlock_t *lock,\n"
  "  const pthread_rwlockattr_t *attr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (*(signed char *)lock)=0;\n"
  "  if(attr!=0) (void)*attr;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_cleanup(lock, pthread_rwlock_cleanup);\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_rdlock",
  "#line 1 \"<builtin-library-pthread_rwlock_rdlock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#define RWLOCK_WRITE_BIAS 127\n"
  "\n"
  "int pthread_rwlock_rdlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  // __CPROVER_assert(*((signed char *)lock)!=-1,\n"
  "  //   \"lock not initialised or destroyed\");\n"
  "  __CPROVER_assume(*((signed char *)lock) != RWLOCK_WRITE_BIAS);\n"
  "  (*((signed char *)lock))++;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  \n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_tryrdlock",
  "#line 1 \"<builtin-library-pthread_rwlock_tryrdlock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if((*(signed char *)lock &2)!=0) { __CPROVER_atomic_end(); return 1; }\n"
  "  (*(signed char *)lock)|=1;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_trywrlock",
  "#line 1 \"<builtin-library-pthread_rwlock_trywrlock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int pthread_rwlock_trywrlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(*(signed char *)lock) { __CPROVER_atomic_end(); return 1; }\n"
  "  (*(signed char *)lock)=2;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_unlock",
  "#line 1 \"<builtin-library-pthread_rwlock_unlock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#define RWLOCK_WRITE_BIAS 127\n"
  "\n"
  "int pthread_rwlock_unlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // __CPROVER_assert(*((signed char *)lock)==1,\n"
  "  //   \"must hold lock upon unlock\");\n"
  "  // TODO: unlocks all held locks at once\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(*((signed char *)lock) == RWLOCK_WRITE_BIAS)\n"
  "    *((signed char *)lock)=0;\n"
  "  else\n"
  "    (*((signed char *)lock))--;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_wrlock",
  "#line 1 \"<builtin-library-pthread_rwlock_wrlock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#define RWLOCK_WRITE_BIAS 127\n"
  "\n"
  "int pthread_rwlock_wrlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  // __CPROVER_assert(*((signed char *)lock)!=-1,\n"
  "  //   \"lock not initialised or destroyed\");\n"
  "  __CPROVER_assume(!*((signed char *)lock));\n"
  "  *((signed char *)lock)=RWLOCK_WRITE_BIAS;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "__spawned_thread",
  "#line 1 \"<builtin-library-__spawned_thread>\"\n"
  "\n"
  "extern __CPROVER_bool __CPROVER_threads_exited[];\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_thread_id;\n"
  "\n"
  "extern __CPROVER_thread_local const void *__CPROVER_thread_keys[];\n"
  "extern __CPROVER_thread_local void (*__CPROVER_thread_key_dtors[])(void *);\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_next_thread_key;\n"
  "\n"
  "void __spawned_thread(\n"
  "  unsigned long this_thread_id,\n"
  "#if 0\n"
  "  // Destructor support is disabled as it is too expensive due to its extensive\n"
  "  // use of shared variables.\n"
  "  void (**thread_key_dtors)(void *),\n"
  "#endif\n"
  "  unsigned long next_thread_key,\n"
  "  void *(*start_routine)(void *),\n"
  "  void *arg)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_thread_id = this_thread_id;\n"
  "  __CPROVER_next_thread_key = next_thread_key;\n"
  "#if 0\n"
  "  // Destructor support is disabled as it is too expensive due to its extensive\n"
  "  // use of shared variables.\n"
  "  for(unsigned long i = 0; i < __CPROVER_next_thread_key; ++i)\n"
  "    __CPROVER_thread_key_dtors[i] = thread_key_dtors[i];\n"
  "#endif\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  // Clear all locked mutexes; locking must happen in same thread.\n"
  "  __CPROVER_clear_must(0, \"mutex-locked\");\n"
  "  __CPROVER_clear_may(0, \"mutex-locked\");\n"
  "#endif\n"
  "  start_routine(arg);\n"
  "  __CPROVER_fence(\n"
  "    \"WWfence\",\n"
  "    \"RRfence\",\n"
  "    \"RWfence\",\n"
  "    \"WRfence\",\n"
  "    \"WWcumul\",\n"
  "    \"RRcumul\",\n"
  "    \"RWcumul\",\n"
  "    \"WRcumul\");\n"
  "#if 0\n"
  "  // Destructor support is disabled as it is too expensive due to its extensive\n"
  "  // use of shared variables.\n"
  "  for(unsigned long i = 0; i < __CPROVER_next_thread_key; ++i)\n"
  "  {\n"
  "    const void *key = __CPROVER_thread_keys[i];\n"
  "    __CPROVER_thread_keys[i] = 0;\n"
  "    if(__CPROVER_thread_key_dtors[i] && key)\n"
  "      __CPROVER_thread_key_dtors[i](key);\n"
  "  }\n"
  "#endif\n"
  "  __CPROVER_threads_exited[this_thread_id] = 1;\n"
  "}\n"
  "\n"
},
{ "pthread_create",
  "#line 1 \"<builtin-library-pthread_create>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#  include <pthread.h>\n"
  "#  define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern unsigned long __CPROVER_next_thread_id;\n"
  "\n"
  "void __spawned_thread(\n"
  "  unsigned long this_thread_id,\n"
  "#if 0\n"
  "  // Destructor support is disabled as it is too expensive due to its extensive\n"
  "  // use of shared variables.\n"
  "  void (**thread_key_dtors)(void *),\n"
  "#endif\n"
  "  unsigned long next_thread_key,\n"
  "  void *(*start_routine)(void *),\n"
  "  void *arg);\n"
  "\n"
  "int pthread_create(\n"
  "  pthread_t *thread,              // must not be null\n"
  "  const pthread_attr_t *attr,     // may be null\n"
  "  void *(*start_routine)(void *), // must not be null\n"
  "  void *arg)                      // may be null\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  unsigned long this_thread_id;\n"
  "  __CPROVER_atomic_begin();\n"
  "  this_thread_id=++__CPROVER_next_thread_id;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  // pthread_t is a pointer type on some systems\n"
  "  *thread=(pthread_t)this_thread_id;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_set_must(thread, \"pthread-id\");\n"
  "  #endif\n"
  "\n"
  "  if(attr) (void)*attr;\n"
  "\n"
  "  unsigned long next_thread_key = __CPROVER_next_thread_key;\n"
  "#if 0\n"
  "  // Destructor support is disabled as it is too expensive due to its extensive\n"
  "  // use of shared variables.\n"
  "  void (**thread_key_dtors)(void *) = __CPROVER_thread_key_dtors;\n"
  "#endif\n"
  "\n"
  "  __CPROVER_ASYNC_1:\n"
  "    __spawned_thread(\n"
  "      this_thread_id,\n"
  "#if 0\n"
  "      // Destructor support is disabled as it is too expensive due to its\n"
  "      // extensive use of shared variables.\n"
  "      thread_key_dtors,\n"
  "#endif\n"
  "      next_thread_key,\n"
  "      start_routine,\n"
  "      arg);\n"
  "\n"
  "    return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_cond_init",
  "#line 1 \"<builtin-library-pthread_cond_init>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)\n"
  "{ __CPROVER_HIDE:\n"
  "  *((unsigned *)cond)=0;\n"
  "  if(attr) (void)*attr;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_cond_signal",
  "#line 1 \"<builtin-library-pthread_cond_signal>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int pthread_cond_signal(pthread_cond_t *cond)\n"
  "{ __CPROVER_HIDE:\n"
  "  __CPROVER_atomic_begin();\n"
  "  (*((unsigned *)cond))++;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_cond_broadcast",
  "#line 1 \"<builtin-library-pthread_cond_broadcast>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int pthread_cond_broadcast(pthread_cond_t *cond)\n"
  "{ __CPROVER_HIDE:\n"
  "  __CPROVER_atomic_begin();\n"
  "  *((unsigned *)cond)=(unsigned)-1;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_cond_wait",
  "#line 1 \"<builtin-library-pthread_cond_wait>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)\n"
  "{ __CPROVER_HIDE:\n"
  "\n"
  "  (void)*mutex;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(mutex, \"mutex-init\"),\n"
  "                   \"mutex must be initialized\");\n"
  "\n"
  "  __CPROVER_assert(__CPROVER_get_must(mutex, \"mutex-locked\"),\n"
  "                   \"mutex must be locked\");\n"
  "\n"
  "  __CPROVER_assert(!__CPROVER_get_may(mutex, \"mutex-destroyed\"),\n"
  "                   \"mutex must not be destroyed\");\n"
  "\n"
  "  __CPROVER_clear_may(mutex, \"mutex-locked\");\n"
  "  #endif\n"
  "  pthread_mutex_unlock(mutex);\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(*((unsigned *)cond))\n"
  "    (*((unsigned *)cond))--;\n"
  "  // __CPROVER_assume(*((unsigned *)cond));\n"
  "  // (*((unsigned *)cond))--;\n"
  "  __CPROVER_atomic_end();\n"
  "  pthread_mutex_lock(mutex);\n"
  "\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_spin_lock",
  "#line 1 \"<builtin-library-pthread_spin_lock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// no pthread_spinlock_t on the Mac\n"
  "#ifndef __APPLE__\n"
  "int pthread_spin_lock(pthread_spinlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assume(!*((unsigned *)lock));\n"
  "  (*((unsigned *)lock))=1;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  return 0;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_spin_unlock",
  "#line 1 \"<builtin-library-pthread_spin_unlock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// no pthread_spinlock_t on the Mac\n"
  "#ifndef __APPLE__\n"
  "int pthread_spin_unlock(pthread_spinlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // This is atomic_full_barrier() in glibc.\n"
  "  // The fence must be before the unlock.\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  *((unsigned *)lock) = 0;\n"
  "  return 0;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_spin_trylock",
  "#line 1 \"<builtin-library-pthread_spin_trylock>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// no pthread_spinlock_t on the Mac\n"
  "#ifndef __APPLE__\n"
  "int pthread_spin_trylock(pthread_spinlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(*((unsigned *)lock))\n"
  "    result=EBUSY;\n"
  "  else\n"
  "  {\n"
  "    result=0;\n"
  "    (*((unsigned *)lock))=1;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  return result;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_barrier_init",
  "#line 1 \"<builtin-library-pthread_barrier_init>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "// no pthread_barrier_t on the Mac\n"
  "// slightly different declaration on OpenBSD\n"
  "#if !defined(__APPLE__) && !defined(__OpenBSD__)\n"
  "int pthread_barrier_init(\n"
  "  pthread_barrier_t *restrict barrier,\n"
  "  const pthread_barrierattr_t *restrict attr,\n"
  "  unsigned count)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)barrier;\n"
  "  (void)attr;\n"
  "  (void)count;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_set_must(barrier, \"barrier-init\");\n"
  "  __CPROVER_clear_may(barrier, \"barrier-destroyed\");\n"
  "  #endif\n"
  "\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "  return result;\n"
  "}\n"
  "#endif\n"
  "\n"
  "// pthread_barrier_init has a slightly different decl on OpenBSD\n"
  "#if defined(__OpenBSD__)\n"
  "int pthread_barrier_init(\n"
  "  pthread_barrier_t *restrict barrier,\n"
  "  pthread_barrierattr_t *restrict attr,\n"
  "  unsigned count)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  (void)barrier;\n"
  "  (void)attr;\n"
  "  (void)count;\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_set_must(barrier, \"barrier-init\");\n"
  "  __CPROVER_clear_may(barrier, \"barrier-destroyed\");\n"
  "#endif\n"
  "\n"
  "  int result = __VERIFIER_nondet_int();\n"
  "  return result;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_barrier_destroy",
  "#line 1 \"<builtin-library-pthread_barrier_destroy>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "// no pthread_barrier_t on the Mac\n"
  "#ifndef __APPLE__\n"
  "int pthread_barrier_destroy(pthread_barrier_t *barrier)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  (void)barrier;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(barrier, \"barrier-init\"),\n"
  "                   \"pthread barrier must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(barrier, \"barrier-destroyed\"),\n"
  "                   \"pthread barrier must not be destroyed\");\n"
  "  __CPROVER_set_may(barrier, \"barrier-destroyed\");\n"
  "  #endif\n"
  "\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "  return result;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_barrier_wait",
  "#line 1 \"<builtin-library-pthread_barrier_wait>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "// no pthread_barrier_t on the Mac\n"
  "#ifndef __APPLE__\n"
  "int pthread_barrier_wait(pthread_barrier_t *barrier)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  (void)barrier;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(barrier, \"barrier-init\"),\n"
  "                   \"pthread barrier must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(barrier, \"barrier-destroyed\"),\n"
  "                   \"pthread barrier must not be destroyed\");\n"
  "  #endif\n"
  "\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "  return result;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_key_create",
  "#line 1 \"<builtin-library-pthread_key_create>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_thread_local const void *__CPROVER_thread_keys[];\n"
  "extern __CPROVER_thread_local void (*__CPROVER_thread_key_dtors[])(void *);\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_next_thread_key;\n"
  "\n"
  "int pthread_key_create(pthread_key_t *key, void (*destructor)(void *))\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_thread_keys[__CPROVER_next_thread_key] = 0;\n"
  "#if 0\n"
  "  // Destructor support is disabled as it is too expensive due to its extensive\n"
  "  // use of shared variables.\n"
  "  __CPROVER_thread_key_dtors[__CPROVER_next_thread_key] = destructor;\n"
  "#else\n"
  "  // __CPROVER_precondition(destructor == 0, \"destructors are not yet supported\");\n"
  "#endif\n"
  "  *key = __CPROVER_next_thread_key++;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_key_delete",
  "#line 1 \"<builtin-library-pthread_key_delete>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_thread_local const void *__CPROVER_thread_keys[];\n"
  "\n"
  "int pthread_key_delete(pthread_key_t key)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_thread_keys[key] = 0;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_getspecific",
  "#line 1 \"<builtin-library-pthread_getspecific>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_thread_local const void *__CPROVER_thread_keys[];\n"
  "\n"
  "void *pthread_getspecific(pthread_key_t key)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  return (void *)__CPROVER_thread_keys[key];\n"
  "}\n"
  "\n"
},
{ "pthread_setspecific",
  "#line 1 \"<builtin-library-pthread_setspecific>\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_thread_local const void *__CPROVER_thread_keys[];\n"
  "\n"
  "int pthread_setspecific(pthread_key_t key, const void *value)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_thread_keys[key] = value;\n"
  "  return 0;\n"
  "}\n"
},
{ "getrandom",
  "#line 1 \"<builtin-library-getrandom>\"\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#if defined(__GLIBC__) &&                                                      \\\n"
  "  (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25))\n"
  "\n"
  "#  ifndef __CPROVER_SYS_RANDOM_H_INCLUDED\n"
  "#    include <sys/random.h>\n"
  "#    define __CPROVER_SYS_RANDOM_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "#  ifndef GRND_NONBLOCK\n"
  "#    define GRND_NONBLOCK 0\n"
  "#  endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "size_t __VERIFIER_nondet_size_t();\n"
  "\n"
  "ssize_t getrandom(void *buf, size_t buflen, unsigned int flags)\n"
  "{\n"
  "  if(flags & GRND_NONBLOCK && __VERIFIER_nondet___CPROVER_bool())\n"
  "    return -1;\n"
  "\n"
  "  char bytes[buflen];\n"
  "  __CPROVER_array_replace(buf, bytes);\n"
  "\n"
  "  size_t actual_bytes = __VERIFIER_nondet_size_t();\n"
  "  __CPROVER_assume(actual_bytes <= buflen);\n"
  "  return (ssize_t)actual_bytes;\n"
  "}\n"
  "\n"
  "#endif\n"
},
{ "sem_init",
  "#line 1 \"<builtin-library-sem_init>\"\n"
  "\n"
  "#include <semaphore.h>\n"
  "\n"
  "typedef unsigned int __CPROVER_sem_t;\n"
  "\n"
  "int sem_init(sem_t *sem, int pshared, unsigned int value)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // (void)pshared;\n"
  "  // (void)value;\n"
  "  // (void)sem;\n"
  "\n"
  "  // #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  // __CPROVER_set_must(sem, \"sem-init\");\n"
  "  // __CPROVER_clear_may(sem, \"sem-destroyed\");\n"
  "  // #endif\n"
  "  *((__CPROVER_sem_t *)sem)=value;\n"
  "  (void)pshared;\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "sem_wait",
  "#line 1 \"<builtin-library-sem_wait>\"\n"
  "\n"
  "#include <semaphore.h>\n"
  "\n"
  "typedef unsigned int __CPROVER_sem_t;\n"
  "\n"
  "int sem_wait(sem_t *sem)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // (void)sem;\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assume(*((__CPROVER_sem_t *)sem));\n"
  "  (*((__CPROVER_sem_t *)sem))--;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(sem, \"sem-init\"),\n"
  "                   \"semaphore must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(sem, \"sem-destroyed\"),\n"
  "                   \"semaphore must not be destroyed\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "sem_timedwait",
  "#line 1 \"<builtin-library-sem_timedwait>\"\n"
  "\n"
  "#include <semaphore.h>\n"
  "\n"
  "int sem_timedwait(sem_t *sem, const struct timespec *abstime)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)sem;\n"
  "  (void)abstime;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(sem, \"sem-init\"),\n"
  "                   \"semaphore must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(sem, \"sem-destroyed\"),\n"
  "                   \"semaphore must not be destroyed\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "sem_trywait",
  "#line 1 \"<builtin-library-sem_trywait>\"\n"
  "\n"
  "#include <semaphore.h>\n"
  "\n"
  "int sem_trywait(sem_t *sem)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)sem;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(sem, \"sem-init\"),\n"
  "                   \"semaphore must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(sem, \"sem-destroyed\"),\n"
  "                   \"semaphore must not be destroyed\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "sem_post",
  "#line 1 \"<builtin-library-sem_post>\"\n"
  "\n"
  "#include <semaphore.h>\n"
  "\n"
  "typedef unsigned int __CPROVER_sem_t;\n"
  "\n"
  "int sem_post(sem_t *sem)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  //(void)sem;\n"
  "  __CPROVER_atomic_begin();\n"
  "  (*((__CPROVER_sem_t *)sem))++;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(sem, \"sem-init\"),\n"
  "                   \"semaphore must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(sem, \"sem-destroyed\"),\n"
  "                   \"semaphore must not be destroyed\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "sem_post_multiple",
  "#line 1 \"<builtin-library-sem_post_multiple>\"\n"
  "\n"
  "#include <semaphore.h>\n"
  "\n"
  "int sem_post_multiple(sem_t *sem, int number)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)sem;\n"
  "  (void)number;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(sem, \"sem-init\"),\n"
  "                   \"semaphore must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(sem, \"sem-destroyed\"),\n"
  "                   \"semaphore must not be destroyed\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "sem_getvalue",
  "#line 1 \"<builtin-library-sem_getvalue>\"\n"
  "\n"
  "#include <semaphore.h>\n"
  "\n"
  "int sem_getvalue(sem_t *sem, int *sval)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)sem;\n"
  "  (void)sval;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(sem, \"sem-init\"),\n"
  "                   \"semaphore must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(sem, \"sem-destroyed\"),\n"
  "                   \"semaphore must not be destroyed\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "sem_destroy",
  "#line 1 \"<builtin-library-sem_destroy>\"\n"
  "\n"
  "#include <semaphore.h>\n"
  "\n"
  "int sem_destroy(sem_t *sem)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)sem;\n"
  "\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(sem, \"sem-init\"),\n"
  "                   \"semaphore must be initialized\");\n"
  "  __CPROVER_assert(!__CPROVER_get_may(sem, \"sem-destroyed\"),\n"
  "                   \"semaphore must not be destroyed\");\n"
  "  __CPROVER_set_may(sem, \"sem-destroyed\");\n"
  "  #endif\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "longjmp",
  "#line 1 \"<builtin-library-longjmp>\"\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void longjmp(jmp_buf env, int val)\n"
  "{\n"
  "  // does not return\n"
  "  (void)env;\n"
  "  (void)val;\n"
  "  __CPROVER_assert(0, \"longjmp requires instrumentation\");\n"
  "  __CPROVER_assume(0);\n"
  "#ifdef LIBRARY_CHECK\n"
  "  __builtin_unreachable();\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "_longjmp",
  "#line 1 \"<builtin-library-_longjmp>\"\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void _longjmp(jmp_buf env, int val)\n"
  "{\n"
  "  // does not return\n"
  "  (void)env;\n"
  "  (void)val;\n"
  "  __CPROVER_assert(0, \"_longjmp requires instrumentation\");\n"
  "  __CPROVER_assume(0);\n"
  "#ifdef LIBRARY_CHECK\n"
  "  __builtin_unreachable();\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "siglongjmp",
  "#line 1 \"<builtin-library-siglongjmp>\"\n"
  "\n"
  "#ifndef _WIN32\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void siglongjmp(sigjmp_buf env, int val)\n"
  "{\n"
  "  // does not return\n"
  "  (void)env;\n"
  "  (void)val;\n"
  "  __CPROVER_assert(0, \"siglongjmp requires instrumentation\");\n"
  "  __CPROVER_assume(0);\n"
  "#ifdef LIBRARY_CHECK\n"
  "  __builtin_unreachable();\n"
  "#endif\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "setjmp",
  "#line 1 \"<builtin-library-setjmp>\"\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef setjmp\n"
  "\n"
  "int setjmp(jmp_buf env)\n"
  "{\n"
  "  (void)env;\n"
  "  // returns via longjmp require instrumentation; only such returns would\n"
  "  // return a non-zero value\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "_setjmp",
  "#line 1 \"<builtin-library-_setjmp>\"\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int _setjmp(jmp_buf env)\n"
  "{\n"
  "  (void)env;\n"
  "  // returns via longjmp require instrumentation; only such returns would\n"
  "  // return a non-zero value\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "sigsetjmp",
  "#line 1 \"<builtin-library-sigsetjmp>\"\n"
  "\n"
  "#ifndef _WIN32\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#  include <setjmp.h>\n"
  "#  define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef sigsetjmp\n"
  "\n"
  "int sigsetjmp(sigjmp_buf env, int savesigs)\n"
  "{\n"
  "  (void)env;\n"
  "  (void)savesigs;\n"
  "  // returns via siglongjmp require instrumentation; only such returns would\n"
  "  // return a non-zero value\n"
  "  return 0;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "__sigsetjmp",
  "#line 1 \"<builtin-library-__sigsetjmp>\"\n"
  "\n"
  "#ifndef _WIN32\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#  include <setjmp.h>\n"
  "#  define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __sigsetjmp(sigjmp_buf env, int savesigs)\n"
  "{\n"
  "  (void)env;\n"
  "  (void)savesigs;\n"
  "  // returns via siglongjmp require instrumentation; only such returns would\n"
  "  // return a non-zero value\n"
  "  return 0;\n"
  "}\n"
  "\n"
  "#endif\n"
},
{ "kill",
  "#line 1 \"<builtin-library-kill>\"\n"
  "\n"
  "#ifndef __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#include <sys/types.h>\n"
  "#define __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_SIGNAL_H_INCLUDED\n"
  "#include <signal.h>\n"
  "#define __CPROVER_SIGNAL_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "int kill(pid_t pid, int sig)\n"
  "{\n"
  "  (void)pid;\n"
  "  (void)sig;\n"
  "  __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "  return error ? -1 : 0;\n"
  "}\n"
  "\n"
},
{ "putchar",
  "#line 1 \"<builtin-library-putchar>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "/* undefine macros in OpenBSD's stdio.h that are problematic to the checker. */\n"
  "#if defined(__OpenBSD__)\n"
  "#undef getchar\n"
  "#undef putchar\n"
  "#undef getc\n"
  "#undef feof\n"
  "#undef ferror\n"
  "#undef fileno\n"
  "#endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "int putchar(int c)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_printf(\"%c\", c);\n"
  "  return (error?-1:c);\n"
  "}\n"
  "\n"
},
{ "puts",
  "#line 1 \"<builtin-library-puts>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int puts(const char *s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "  int ret=__VERIFIER_nondet_int();\n"
  "  __CPROVER_printf(\"%s\\n\", s);\n"
  "  if(error) ret=-1; else __CPROVER_assume(ret>=0);\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "fclose_cleanup",
  "#line 1 \"<builtin-library-fclose_cleanup>\"\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "void fclose_cleanup(void *stream)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_assert(\n"
  "    !__CPROVER_get_must(stream, \"open\") || __CPROVER_get_must(stream, \"closed\"),\n"
  "    \"resource leak: fopen file not closed\");\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "fopen",
  "#line 1 \"<builtin-library-fopen>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void fclose_cleanup(void *stream);\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "FILE *fopen(const char *filename, const char *mode)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*filename;\n"
  "  (void)*mode;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(filename), \"fopen zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(mode), \"fopen zero-termination of 2nd argument\");\n"
  "#endif\n"
  "\n"
  "  FILE *fopen_result;\n"
  "\n"
  "  __CPROVER_bool fopen_error=__VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "  fopen_result=fopen_error?NULL:malloc(sizeof(FILE));\n"
  "#else\n"
  "  // libraries need to expose the definition of FILE; this is the\n"
  "  // case for musl\n"
  "  fopen_result=fopen_error?NULL:malloc(sizeof(int));\n"
  "#endif\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_set_must(fopen_result, \"open\");\n"
  "  __CPROVER_cleanup(fopen_result, fclose_cleanup);\n"
  "#endif\n"
  "\n"
  "  return fopen_result;\n"
  "}\n"
  "\n"
},
{ "_fopen",
  "#line 1 \"<builtin-library-_fopen>\"\n"
  "\n"
  "// This is for Apple; we cannot fall back to fopen as we need\n"
  "// header files to have a definition of FILE available; the same\n"
  "// header files rename fopen to _fopen and would thus yield\n"
  "// unbounded recursion.\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#  include <stdio.h>\n"
  "#  define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#  include <stdlib.h>\n"
  "#  define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void fclose_cleanup(void *stream);\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "#ifdef __APPLE__\n"
  "FILE *_fopen(const char *filename, const char *mode)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  (void)*filename;\n"
  "  (void)*mode;\n"
  "#  ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(\n"
  "    __CPROVER_is_zero_string(filename),\n"
  "    \"fopen zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(\n"
  "    __CPROVER_is_zero_string(mode), \"fopen zero-termination of 2nd argument\");\n"
  "#  endif\n"
  "\n"
  "  FILE *fopen_result;\n"
  "\n"
  "  __CPROVER_bool fopen_error = __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "  fopen_result = fopen_error ? NULL : malloc(sizeof(FILE));\n"
  "\n"
  "#  ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_set_must(fopen_result, \"open\");\n"
  "  __CPROVER_cleanup(fopen_result, fclose_cleanup);\n"
  "#  endif\n"
  "\n"
  "  return fopen_result;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "freopen",
  "#line 1 \"<builtin-library-freopen>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "FILE *freopen(const char *filename, const char *mode, FILE *f)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*filename;\n"
  "  (void)*mode;\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "  (void)*f;\n"
  "#else\n"
  "  (void)*(char*)f;\n"
  "#endif\n"
  "\n"
  "  return f;\n"
  "}\n"
  "\n"
},
{ "fclose",
  "#line 1 \"<builtin-library-fclose>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int fclose(FILE *stream)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fclose file must be open\");\n"
  "  __CPROVER_clear_must(stream, \"open\");\n"
  "  __CPROVER_set_must(stream, \"closed\");\n"
  "#endif\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "  free(stream);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fdopen",
  "#line 1 \"<builtin-library-fdopen>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "FILE *fdopen(int handle, const char *mode)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)handle;\n"
  "  (void)*mode;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(mode),\n"
  "    \"fdopen zero-termination of 2nd argument\");\n"
  "#endif\n"
  "\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "  FILE *f=malloc(sizeof(FILE));\n"
  "#else\n"
  "  // libraries need to expose the definition of FILE; this is the\n"
  "  // case for musl\n"
  "  FILE *f=malloc(sizeof(int));\n"
  "#endif\n"
  "\n"
  "  return f;\n"
  "}\n"
  "\n"
},
{ "_fdopen",
  "#line 1 \"<builtin-library-_fdopen>\"\n"
  "\n"
  "// This is for Apple; we cannot fall back to fdopen as we need\n"
  "// header files to have a definition of FILE available; the same\n"
  "// header files rename fdopen to _fdopen and would thus yield\n"
  "// unbounded recursion.\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifdef __APPLE__\n"
  "FILE *_fdopen(int handle, const char *mode)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)handle;\n"
  "  (void)*mode;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(mode),\n"
  "    \"fdopen zero-termination of 2nd argument\");\n"
  "#endif\n"
  "\n"
  "  FILE *f=malloc(sizeof(FILE));\n"
  "\n"
  "  return f;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "fgets",
  "#line 1 \"<builtin-library-fgets>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "char *fgets(char *str, int size, FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "  (void)size;\n"
  "  if(stream != stdin)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fgets file must be open\");\n"
  "#endif\n"
  "\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  int resulting_size;\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(str)>=size, \"buffer-overflow in fgets\");\n"
  "  if(size>0)\n"
  "  {\n"
  "    __CPROVER_assume(resulting_size<size);\n"
  "    __CPROVER_is_zero_string(str)=!error;\n"
  "    __CPROVER_zero_string_length(str)=resulting_size;\n"
  "  }\n"
  "#else\n"
  "  if(size>0)\n"
  "  {\n"
  "    int str_length=__VERIFIER_nondet_int();\n"
  "    __CPROVER_assume(str_length >= 0 && str_length < size);\n"
  "    __CPROVER_precondition(__CPROVER_w_ok(str, size), \"fgets buffer writable\");\n"
  "    char contents_nondet[str_length];\n"
  "    __CPROVER_array_replace(str, contents_nondet);\n"
  "    if(!error)\n"
  "      str[str_length]='\\0';\n"
  "  }\n"
  "#endif\n"
  "\n"
  "  return error?0:str;\n"
  "}\n"
  "\n"
},
{ "fread",
  "#line 1 \"<builtin-library-fread>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "char __VERIFIER_nondet_char();\n"
  "size_t __VERIFIER_nondet_size_t();\n"
  "\n"
  "size_t fread(void *ptr, size_t size, size_t nitems, FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  size_t nread=__VERIFIER_nondet_size_t();\n"
  "  size_t bytes=nread*size;\n"
  "  __CPROVER_assume(nread<=nitems);\n"
  "\n"
  "  if(stream != stdin)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fread file must be open\");\n"
  "#endif\n"
  "\n"
  "  for(size_t i=0; i<bytes; i++)\n"
  "  {\n"
  "    ((char *)ptr)[i] = __VERIFIER_nondet_char();\n"
  "  }\n"
  "\n"
  "  return nread;\n"
  "}\n"
  "\n"
},
{ "feof",
  "#line 1 \"<builtin-library-feof>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int feof(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "\n"
  "  if(stream != stdin)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"feof file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "ferror",
  "#line 1 \"<builtin-library-ferror>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int ferror(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "\n"
  "  if(stream != stdin)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"feof file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fileno",
  "#line 1 \"<builtin-library-fileno>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int fileno(FILE *stream)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  if(stream == stdin)\n"
  "    return 0;\n"
  "  else if(stream == stdout)\n"
  "    return 1;\n"
  "  else if(stream == stderr)\n"
  "    return 2;\n"
  "\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "  __CPROVER_assume(return_value >= -1);\n"
  "\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "  (void)*stream;\n"
  "#else\n"
  "  (void)*(char*)stream;\n"
  "#endif\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fileno file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fputs",
  "#line 1 \"<builtin-library-fputs>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int fputs(const char *s, FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s), \"fputs zero-termination of 1st argument\");\n"
  "#endif\n"
  "  (void)*s;\n"
  "\n"
  "  if(stream != stdout && stream != stderr)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fputs file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fflush",
  "#line 1 \"<builtin-library-fflush>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int fflush(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "  (void)stream;\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  if(stream)\n"
  "    __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                     \"fflush file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fpurge",
  "#line 1 \"<builtin-library-fpurge>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int fpurge(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "\n"
  "  if(stream != stdin && stream != stdout && stream != stderr)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fpurge file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fgetc",
  "#line 1 \"<builtin-library-fgetc>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int fgetc(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "\n"
  "  if(stream != stdin)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "  // it's a byte or EOF (-1)\n"
  "  __CPROVER_assume(return_value>=-1 && return_value<=255);\n"
  "\n"
  "  __CPROVER_input(\"fgetc\", return_value);\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fgetc file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "getc",
  "#line 1 \"<builtin-library-getc>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int getc(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "\n"
  "  if(stream != stdin)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"getc file must be open\");\n"
  "#endif\n"
  "\n"
  "  // It's a byte or EOF, which we fix to -1.\n"
  "  __CPROVER_assume(return_value>=-1 && return_value<=255);\n"
  "\n"
  "  __CPROVER_input(\"getc\", return_value);\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "getchar",
  "#line 1 \"<builtin-library-getchar>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int getchar()\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "  // it's a byte or EOF\n"
  "  __CPROVER_assume(return_value>=-1 && return_value<=255);\n"
  "  __CPROVER_input(\"getchar\", return_value);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "getw",
  "#line 1 \"<builtin-library-getw>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int getw(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "\n"
  "  if(stream != stdin)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"getw file must be open\");\n"
  "#endif\n"
  "\n"
  "  __CPROVER_input(\"getw\", return_value);\n"
  "\n"
  "  // it's any int, no restriction\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fseek",
  "#line 1 \"<builtin-library-fseek>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int fseek(FILE *stream, long offset, int whence)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value=__VERIFIER_nondet_int();\n"
  "\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "  (void)*stream;\n"
  "#else\n"
  "  (void)*(char*)stream;\n"
  "#endif\n"
  "  (void)offset;\n"
  "  (void)whence;\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fseek file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "ftell",
  "#line 1 \"<builtin-library-ftell>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long __VERIFIER_nondet_long();\n"
  "\n"
  "long ftell(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  long return_value=__VERIFIER_nondet_long();\n"
  "\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "  (void)*stream;\n"
  "#else\n"
  "  (void)*(char*)stream;\n"
  "#endif\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"ftell file must be open\");\n"
  "#endif\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "rewind",
  "#line 1 \"<builtin-library-rewind>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void rewind(FILE *stream)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "  (void)*stream;\n"
  "#else\n"
  "  (void)*(char*)stream;\n"
  "#endif\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"rewind file must be open\");\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "fwrite",
  "#line 1 \"<builtin-library-fwrite>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "size_t __VERIFIER_nondet_size_t();\n"
  "\n"
  "size_t fwrite(\n"
  "  const void *ptr,\n"
  "  size_t size,\n"
  "  size_t nitems,\n"
  "  FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*(char*)ptr;\n"
  "  (void)size;\n"
  "\n"
  "  if(stream != stdout && stream != stderr)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"fwrite file must be open\");\n"
  "#endif\n"
  "\n"
  "  size_t nwrite=__VERIFIER_nondet_size_t();\n"
  "  __CPROVER_assume(nwrite<=nitems);\n"
  "  return nwrite;\n"
  "}\n"
  "\n"
},
{ "perror",
  "#line 1 \"<builtin-library-perror>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void perror(const char *s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if(s!=0)\n"
  "  {\n"
  "    #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "    __CPROVER_assert(__CPROVER_is_zero_string(s), \"perror zero-termination\");\n"
  "    #endif\n"
  "    // should go to stderr\n"
  "    if(s[0]!=0)\n"
  "      __CPROVER_printf(\"%s: \", s);\n"
  "  }\n"
  "\n"
  "  // TODO: print errno error\n"
  "}\n"
  "\n"
},
{ "fscanf",
  "#line 1 \"<builtin-library-fscanf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int fscanf(FILE *restrict stream, const char *restrict format, ...)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result=vfscanf(stream, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "__isoc99_fscanf",
  "#line 1 \"<builtin-library-__isoc99_fscanf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#  include <stdio.h>\n"
  "#  define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#  include <stdarg.h>\n"
  "#  define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __isoc99_fscanf(FILE *restrict stream, const char *restrict format, ...)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result = vfscanf(stream, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "scanf",
  "#line 1 \"<builtin-library-scanf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int scanf(const char *restrict format, ...)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result=vfscanf(stdin, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "sscanf",
  "#line 1 \"<builtin-library-sscanf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int sscanf(const char *restrict s, const char *restrict format, ...)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result=vsscanf(s, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "vfscanf",
  "#line 1 \"<builtin-library-vfscanf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int vfscanf(FILE *restrict stream, const char *restrict format, va_list arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "\n"
  "  if(stream != stdin)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "  (void)*format;\n"
  "  (void)arg;\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"vfscanf file must be open\");\n"
  "#endif\n"
  "\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "vscanf",
  "#line 1 \"<builtin-library-vscanf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int vscanf(const char *restrict format, va_list arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return vfscanf(stdin, format, arg);\n"
  "}\n"
  "\n"
},
{ "vsscanf",
  "#line 1 \"<builtin-library-vsscanf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int vsscanf(const char *restrict s, const char *restrict format, va_list arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "  (void)*s;\n"
  "  (void)*format;\n"
  "  (void)arg;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "printf",
  "#line 1 \"<builtin-library-printf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#  include <stdio.h>\n"
  "#  define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#  include <stdarg.h>\n"
  "#  define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int printf(const char *format, ...)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  int result = __VERIFIER_nondet_int();\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  __CPROVER_printf(format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "fprintf",
  "#line 1 \"<builtin-library-fprintf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int fprintf(FILE *stream, const char *restrict format, ...)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result=vfprintf(stream, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "vfprintf",
  "#line 1 \"<builtin-library-vfprintf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int vfprintf(FILE *stream, const char *restrict format, va_list arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  int result=__VERIFIER_nondet_int();\n"
  "\n"
  "  if(stream != stdout && stream != stderr)\n"
  "  {\n"
  "#if !defined(__linux__) || defined(__GLIBC__)\n"
  "    (void)*stream;\n"
  "#else\n"
  "    (void)*(char *)stream;\n"
  "#endif\n"
  "  }\n"
  "\n"
  "  (void)*format;\n"
  "  (void)arg;\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_assert(__CPROVER_get_must(stream, \"open\"),\n"
  "                   \"vfprintf file must be open\");\n"
  "#endif\n"
  "\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "vasprintf",
  "#line 1 \"<builtin-library-vasprintf>\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "char __VERIFIER_nondet_char();\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int vasprintf(char **ptr, const char *fmt, va_list ap)\n"
  "{\n"
  "  (void)*fmt;\n"
  "  (void)ap;\n"
  "\n"
  "  int result_buffer_size=__VERIFIER_nondet_int();\n"
  "  if(result_buffer_size<=0)\n"
  "    return -1;\n"
  "\n"
  "  *ptr=malloc(result_buffer_size);\n"
  "  int i=0;\n"
  "  for( ; i<result_buffer_size; ++i)\n"
  "  {\n"
  "    char c=__VERIFIER_nondet_char();\n"
  "    (*ptr)[i]=c;\n"
  "    if(c=='\\0')\n"
  "      break;\n"
  "  }\n"
  "\n"
  "  __CPROVER_assume(i<result_buffer_size);\n"
  "\n"
  "  return i;\n"
  "}\n"
  "\n"
},
{ "__acrt_iob_func",
  "#line 1 \"<builtin-library-__acrt_iob_func>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "#  ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#    include <stdio.h>\n"
  "#    define __CPROVER_STDIO_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "FILE *__acrt_iob_func(unsigned fd)\n"
  "{\n"
  "  static FILE stdin_file;\n"
  "  static FILE stdout_file;\n"
  "  static FILE stderr_file;\n"
  "\n"
  "  switch(fd)\n"
  "  {\n"
  "  case 0:\n"
  "    return &stdin_file;\n"
  "  case 1:\n"
  "    return &stdout_file;\n"
  "  case 2:\n"
  "    return &stderr_file;\n"
  "  default:\n"
  "    return (FILE *)0;\n"
  "  }\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "__stdio_common_vfprintf",
  "#line 1 \"<builtin-library-__stdio_common_vfprintf>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "#  ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#    include <stdio.h>\n"
  "#    define __CPROVER_STDIO_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "#  ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#    include <stdarg.h>\n"
  "#    define __CPROVER_STDARG_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "int __stdio_common_vfprintf(\n"
  "  unsigned __int64 options,\n"
  "  FILE *stream,\n"
  "  char const *format,\n"
  "  _locale_t locale,\n"
  "  va_list args)\n"
  "{\n"
  "  (void)options;\n"
  "  (void)locale;\n"
  "\n"
  "  if(stream == __acrt_iob_func(1))\n"
  "    __CPROVER_printf(format, args);\n"
  "  return 0;\n"
  "}\n"
  "\n"
  "#endif\n"
},
{ "abs",
  "#line 1 \"<builtin-library-abs>\"\n"
  "\n"
  "#undef abs\n"
  "\n"
  "int abs(int i)\n"
  "{\n"
  "  return __CPROVER_abs(i);\n"
  "}\n"
  "\n"
},
{ "labs",
  "#line 1 \"<builtin-library-labs>\"\n"
  "\n"
  "#undef labs\n"
  "\n"
  "long int labs(long int i)\n"
  "{\n"
  "  return __CPROVER_labs(i);\n"
  "}\n"
  "\n"
},
{ "llabs",
  "#line 1 \"<builtin-library-llabs>\"\n"
  "\n"
  "#undef llabs\n"
  "\n"
  "long long int llabs(long long int i)\n"
  "{\n"
  "  return __CPROVER_llabs(i);\n"
  "}\n"
  "\n"
},
{ "__builtin_abs",
  "#line 1 \"<builtin-library-__builtin_abs>\"\n"
  "\n"
  "int __builtin_abs(int i)\n"
  "{\n"
  "  return __CPROVER_abs(i);\n"
  "}\n"
  "\n"
},
{ "__builtin_labs",
  "#line 1 \"<builtin-library-__builtin_labs>\"\n"
  "\n"
  "long int __builtin_labs(long int i)\n"
  "{\n"
  "  return __CPROVER_labs(i);\n"
  "}\n"
  "\n"
},
{ "__builtin_llabs",
  "#line 1 \"<builtin-library-__builtin_llabs>\"\n"
  "\n"
  "long long int __builtin_llabs(long long int i)\n"
  "{\n"
  "  return __CPROVER_llabs(i);\n"
  "}\n"
  "\n"
},
{ "exit",
  "#line 1 \"<builtin-library-exit>\"\n"
  "\n"
  "#undef exit\n"
  "\n"
  "void exit(int status)\n"
  "{\n"
  "  (void)status;\n"
  "  __CPROVER_assume(0);\n"
  "#ifdef LIBRARY_CHECK\n"
  "  __builtin_unreachable();\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "_Exit",
  "#line 1 \"<builtin-library-_Exit>\"\n"
  "\n"
  "#undef _Exit\n"
  "\n"
  "void _Exit(int status)\n"
  "{\n"
  "  (void)status;\n"
  "  __CPROVER_assume(0);\n"
  "#ifdef LIBRARY_CHECK\n"
  "  __builtin_unreachable();\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "abort",
  "#line 1 \"<builtin-library-abort>\"\n"
  "\n"
  "#undef abort\n"
  "\n"
  "void abort(void)\n"
  "{\n"
  "  __CPROVER_assume(0);\n"
  "#ifdef LIBRARY_CHECK\n"
  "  __builtin_unreachable();\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "calloc",
  "#line 1 \"<builtin-library-calloc>\"\n"
  "\n"
  "#undef calloc\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "#ifndef __GNUC__\n"
  "_Bool __builtin_mul_overflow();\n"
  "#endif\n"
  "\n"
  "void *calloc(__CPROVER_size_t nmemb, __CPROVER_size_t size)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  __CPROVER_size_t alloc_size;\n"
  "  // if(__builtin_mul_overflow(nmemb, size, &alloc_size))\n"
  "  //   return (void *)0;\n"
  "\n"
  "  if(__CPROVER_malloc_failure_mode == __CPROVER_malloc_failure_mode_return_null)\n"
  "  {\n"
  "    __CPROVER_bool should_malloc_fail = __VERIFIER_nondet___CPROVER_bool();\n"
  "    if(\n"
  "      alloc_size > __CPROVER_max_malloc_size ||\n"
  "      (__CPROVER_malloc_may_fail && should_malloc_fail))\n"
  "    {\n"
  "      return (void *)0;\n"
  "    }\n"
  "  }\n"
  "  else if(\n"
  "    __CPROVER_malloc_failure_mode ==\n"
  "    __CPROVER_malloc_failure_mode_assert_then_assume)\n"
  "  {\n"
  "    // __CPROVER_assert(\n"
  "    //   alloc_size <= __CPROVER_max_malloc_size, \"max allocation size exceeded\");\n"
  "    __CPROVER_assume(alloc_size <= __CPROVER_max_malloc_size);\n"
  "\n"
  "    __CPROVER_bool should_malloc_fail = __VERIFIER_nondet___CPROVER_bool();\n"
  "    // __CPROVER_assert(\n"
  "    //   !__CPROVER_malloc_may_fail || !should_malloc_fail,\n"
  "    //   \"max allocation may fail\");\n"
  "    __CPROVER_assume(!__CPROVER_malloc_may_fail || !should_malloc_fail);\n"
  "  }\n"
  "\n"
  "  void *malloc_res;\n"
  "  // realistically, calloc may return NULL,\n"
  "  // and __CPROVER_allocate doesn't, but no one cares\n"
  "  malloc_res = __CPROVER_allocate(alloc_size, 1);\n"
  "\n"
  "  // make sure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated =\n"
  "    (malloc_res == __CPROVER_deallocated) ? 0 : __CPROVER_deallocated;\n"
  "\n"
  "  // record the object size for non-determistic bounds checking\n"
  "  __CPROVER_bool record_malloc = __VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_malloc_is_new_array =\n"
  "    record_malloc ? 0 : __CPROVER_malloc_is_new_array;\n"
  "\n"
  "  // detect memory leaks\n"
  "  __CPROVER_bool record_may_leak = __VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_memory_leak = record_may_leak ? malloc_res : __CPROVER_memory_leak;\n"
  "\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assume(__CPROVER_buffer_size(malloc_res) == alloc_size);\n"
  "  __CPROVER_is_zero_string(malloc_res) = 1;\n"
  "  __CPROVER_zero_string_length(malloc_res) = 0;\n"
  "#endif\n"
  "\n"
  "  return malloc_res;\n"
  "}\n"
  "\n"
},
{ "malloc",
  "#line 1 \"<builtin-library-malloc>\"\n"
  "\n"
  "#undef malloc\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "// malloc is marked \"inline\" for the benefit of goto-analyzer. Really,\n"
  "// goto-analyzer should take care of inlining as needed.\n"
  "inline void *malloc(__CPROVER_size_t malloc_size)\n"
  "{\n"
  "// realistically, malloc may return NULL,\n"
  "// but we only do so if `--malloc-may-fail` is set\n"
  "__CPROVER_HIDE:;\n"
  "\n"
  "  if(__CPROVER_malloc_failure_mode == __CPROVER_malloc_failure_mode_return_null)\n"
  "  {\n"
  "    __CPROVER_bool should_malloc_fail = __VERIFIER_nondet___CPROVER_bool();\n"
  "    if(\n"
  "      malloc_size > __CPROVER_max_malloc_size ||\n"
  "      (__CPROVER_malloc_may_fail && should_malloc_fail))\n"
  "    {\n"
  "      return (void *)0;\n"
  "    }\n"
  "  }\n"
  "  else if(\n"
  "    __CPROVER_malloc_failure_mode ==\n"
  "    __CPROVER_malloc_failure_mode_assert_then_assume)\n"
  "  {\n"
  "    // __CPROVER_assert(\n"
  "    //   malloc_size <= __CPROVER_max_malloc_size, \"max allocation size exceeded\");\n"
  "    // __CPROVER_assume(malloc_size <= __CPROVER_max_malloc_size);\n"
  "\n"
  "    __CPROVER_bool should_malloc_fail = __VERIFIER_nondet___CPROVER_bool();\n"
  "    // __CPROVER_assert(\n"
  "    //   !__CPROVER_malloc_may_fail || !should_malloc_fail,\n"
  "    //   \"max allocation may fail\");\n"
  "    __CPROVER_assume(!__CPROVER_malloc_may_fail || !should_malloc_fail);\n"
  "  }\n"
  "\n"
  "  void *malloc_res;\n"
  "  malloc_res = __CPROVER_allocate(malloc_size, 0);\n"
  "\n"
  "  // make sure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated =\n"
  "    (malloc_res == __CPROVER_deallocated) ? 0 : __CPROVER_deallocated;\n"
  "\n"
  "  // record the object size for non-determistic bounds checking\n"
  "  __CPROVER_bool record_malloc = __VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_malloc_is_new_array =\n"
  "    record_malloc ? 0 : __CPROVER_malloc_is_new_array;\n"
  "\n"
  "  // detect memory leaks\n"
  "  __CPROVER_bool record_may_leak = __VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_memory_leak = record_may_leak ? malloc_res : __CPROVER_memory_leak;\n"
  "\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assume(__CPROVER_buffer_size(malloc_res) == malloc_size);\n"
  "#endif\n"
  "\n"
  "  return malloc_res;\n"
  "}\n"
  "\n"
},
{ "__builtin_alloca",
  "#line 1 \"<builtin-library-__builtin_alloca>\"\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "extern void *__CPROVER_alloca_object;\n"
  "\n"
  "void *__builtin_alloca(__CPROVER_size_t alloca_size)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  void *res;\n"
  "  res = __CPROVER_allocate(alloca_size, 0);\n"
  "\n"
  "  // make sure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated=(res==__CPROVER_deallocated)?0:__CPROVER_deallocated;\n"
  "\n"
  "  // record the object size for non-determistic bounds checking\n"
  "  __CPROVER_bool record_malloc=__VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_malloc_is_new_array=record_malloc?0:__CPROVER_malloc_is_new_array;\n"
  "\n"
  "  // record alloca to detect invalid free\n"
  "  __CPROVER_bool record_alloca = __VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_alloca_object = record_alloca ? res : __CPROVER_alloca_object;\n"
  "\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assume(__CPROVER_buffer_size(res) == alloca_size);\n"
  "#endif\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "alloca",
  "#line 1 \"<builtin-library-alloca>\"\n"
  "\n"
  "#undef alloca\n"
  "\n"
  "void *__builtin_alloca(__CPROVER_size_t alloca_size);\n"
  "\n"
  "void *alloca(__CPROVER_size_t alloca_size)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  return __builtin_alloca(alloca_size);\n"
  "}\n"
  "\n"
},
{ "free",
  "#line 1 \"<builtin-library-free>\"\n"
  "\n"
  "#undef free\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "extern void *__CPROVER_alloca_object;\n"
  "\n"
  "void free(void *ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // If ptr is NULL, no operation is performed.\n"
  "  // __CPROVER_precondition(\n"
  "  //   ptr == 0 || __CPROVER_r_ok(ptr, 0),\n"
  "  //   \"free argument must be NULL or valid pointer\");\n"
  "  // __CPROVER_precondition(ptr==0 || __CPROVER_DYNAMIC_OBJECT(ptr),\n"
  "  //                        \"free argument must be dynamic object\");\n"
  "  // __CPROVER_precondition(ptr==0 || __CPROVER_POINTER_OFFSET(ptr)==0,\n"
  "  //                        \"free argument has offset zero\");\n"
  "\n"
  "  // catch double free\n"
  "  // __CPROVER_precondition(ptr==0 || __CPROVER_deallocated!=ptr,\n"
  "  //                        \"double free\");\n"
  "\n"
  "  // catch people who try to use free(...) for stuff\n"
  "  // allocated with new[]\n"
  "  // __CPROVER_precondition(\n"
  "  //   ptr == 0 || __CPROVER_new_object != ptr || !__CPROVER_malloc_is_new_array,\n"
  "  //   \"free called for new[] object\");\n"
  "\n"
  "  // catch people who try to use free(...) with alloca\n"
  "  // __CPROVER_precondition(\n"
  "  //   ptr == 0 || __CPROVER_alloca_object != ptr,\n"
  "  //   \"free called for stack-allocated object\");\n"
  "\n"
  "  if(ptr!=0)\n"
  "  {\n"
  "    __CPROVER_deallocate(ptr);\n"
  "\n"
  "    // detect memory leaks\n"
  "    if(__CPROVER_memory_leak==ptr)\n"
  "      __CPROVER_memory_leak=0;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "strtol",
  "#line 1 \"<builtin-library-strtol>\"\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_LIMITS_H_INCLUDED\n"
  "#include <limits.h>\n"
  "#define __CPROVER_LIMITS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strtol\n"
  "#undef isdigit\n"
  "#undef isspace\n"
  "\n"
  "int isspace(int);\n"
  "int isdigit(int);\n"
  "\n"
  "#ifndef __GNUC__\n"
  "_Bool __builtin_add_overflow();\n"
  "_Bool __builtin_mul_overflow();\n"
  "#endif\n"
  "\n"
  "long strtol(const char *nptr, char **endptr, int base)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(nptr),\n"
  "    \"zero-termination of argument of strtol\");\n"
  "  #endif\n"
  "\n"
  "  if(base==1 || base<0 || base>36)\n"
  "  {\n"
  "    errno=EINVAL;\n"
  "    return 0;\n"
  "  }\n"
  "\n"
  "  long res=0;\n"
  "  _Bool in_number=0;\n"
  "  char sign=0;\n"
  "\n"
  "  // 32 chars is an arbitrarily chosen limit\n"
  "  int i=0;\n"
  "  for( ; i<31; ++i)\n"
  "  {\n"
  "    char ch=nptr[i];\n"
  "    char sub=0;\n"
  "    if(ch==0)\n"
  "      break;\n"
  "    else if((base==0 || base==16) && !in_number &&\n"
  "            ch=='0' && (nptr[i+1]=='x' || nptr[i+1]=='X'))\n"
  "    {\n"
  "      base=16;\n"
  "      in_number=1;\n"
  "      ++i;\n"
  "      continue;\n"
  "    }\n"
  "    else if(base==0 && !in_number && ch=='0')\n"
  "    {\n"
  "      base=8;\n"
  "      in_number=1;\n"
  "      continue;\n"
  "    }\n"
  "    else if(!in_number && !sign && isspace(ch))\n"
  "      continue;\n"
  "    else if(!in_number && !sign && (ch=='-' || ch=='+'))\n"
  "    {\n"
  "      sign=ch;\n"
  "      continue;\n"
  "    }\n"
  "    else if(base>10 && ch>='a' && ch-'a'<base-10)\n"
  "      sub='a'-10;\n"
  "    else if(base>10 && ch>='A' && ch-'A'<base-10)\n"
  "      sub='A'-10;\n"
  "    else if(isdigit(ch))\n"
  "    {\n"
  "      sub='0';\n"
  "      base=base==0 ? 10 : base;\n"
  "    }\n"
  "    else\n"
  "      break;\n"
  "\n"
  "    in_number=1;\n"
  "    _Bool overflow = __builtin_mul_overflow(res, (long)base, &res);\n"
  "    if(overflow || __builtin_add_overflow(res, (long)(ch - sub), &res))\n"
  "    {\n"
  "      errno=ERANGE;\n"
  "      if(sign=='-')\n"
  "        return LONG_MIN;\n"
  "      else\n"
  "        return LONG_MAX;\n"
  "    }\n"
  "  }\n"
  "\n"
  "  if(endptr!=0)\n"
  "    *endptr=(char*)nptr+i;\n"
  "\n"
  "  if(sign=='-')\n"
  "    res*=-1;\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "atoi",
  "#line 1 \"<builtin-library-atoi>\"\n"
  "\n"
  "#undef atoi\n"
  "#undef strtol\n"
  "\n"
  "long strtol(const char *nptr, char **endptr, int base);\n"
  "\n"
  "int atoi(const char *nptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return (int)strtol(nptr, (char **)0, 10);\n"
  "}\n"
  "\n"
},
{ "atol",
  "#line 1 \"<builtin-library-atol>\"\n"
  "\n"
  "#undef atol\n"
  "#undef strtol\n"
  "\n"
  "long strtol(const char *nptr, char **endptr, int base);\n"
  "\n"
  "long atol(const char *nptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return strtol(nptr, (char **)0, 10);\n"
  "}\n"
  "\n"
},
{ "getenv",
  "#line 1 \"<builtin-library-getenv>\"\n"
  "\n"
  "#undef getenv\n"
  "\n"
  "#ifndef __CPROVER_STDDEF_H_INCLUDED\n"
  "#  include <stddef.h>\n"
  "#  define __CPROVER_STDDEF_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "ptrdiff_t __VERIFIER_nondet_ptrdiff_t();\n"
  "\n"
  "char *getenv(const char *name)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  (void)*name;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(name),\n"
  "    \"zero-termination of argument of getenv\");\n"
  "  #endif\n"
  "\n"
  "#ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_event(\"invalidate_pointer\", \"getenv_result\");\n"
  "  char *getenv_result;\n"
  "  __CPROVER_set_must(getenv_result, \"getenv_result\");\n"
  "  return getenv_result;\n"
  "\n"
  "#else\n"
  "\n"
  "  __CPROVER_bool found=__VERIFIER_nondet___CPROVER_bool();\n"
  "  if(!found) return 0;\n"
  "\n"
  "  ptrdiff_t buf_size = __VERIFIER_nondet_ptrdiff_t();\n"
  "\n"
  "  // It's reasonable to assume this won't exceed the signed\n"
  "  // range in practice, but in principle, this could exceed\n"
  "  // the range.\n"
  "\n"
  "  __CPROVER_assume(buf_size >= 1);\n"
  "  char *buffer = (char *)__CPROVER_allocate(buf_size * sizeof(char), 0);\n"
  "  buffer[buf_size-1]=0;\n"
  "\n"
  "#  ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assume(__CPROVER_buffer_size(buffer) == buf_size);\n"
  "  __CPROVER_is_zero_string(buffer) = 1;\n"
  "  __CPROVER_zero_string_length(buffer) = buf_size - 1;\n"
  "#  endif\n"
  "\n"
  "  return buffer;\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "realloc",
  "#line 1 \"<builtin-library-realloc>\"\n"
  "\n"
  "void *malloc(__CPROVER_size_t malloc_size);\n"
  "void free(void *ptr);\n"
  "\n"
  "void *realloc(void *ptr, __CPROVER_size_t malloc_size)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  __CPROVER_precondition(ptr==0 || __CPROVER_DYNAMIC_OBJECT(ptr),\n"
  "                         \"realloc argument is dynamic object\");\n"
  "\n"
  "  // if ptr is NULL, this behaves like malloc\n"
  "  if(ptr==0)\n"
  "    return malloc(malloc_size);\n"
  "\n"
  "  // if malloc-size is 0, allocate new minimum sized object\n"
  "  // and free original\n"
  "  if(malloc_size==0)\n"
  "  {\n"
  "    free(ptr);\n"
  "    return malloc(1);\n"
  "  }\n"
  "\n"
  "  // this shouldn't move if the new size isn't bigger\n"
  "  void *res;\n"
  "  res=malloc(malloc_size);\n"
  "  if(res != (void *)0)\n"
  "  {\n"
  "    __CPROVER_array_copy(res, ptr);\n"
  "    free(ptr);\n"
  "  }\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "valloc",
  "#line 1 \"<builtin-library-valloc>\"\n"
  "\n"
  "void *malloc(__CPROVER_size_t malloc_size);\n"
  "\n"
  "void *valloc(__CPROVER_size_t malloc_size)\n"
  "{\n"
  "  // The allocated memory is aligned on a page\n"
  "  // boundary, which we don't model.\n"
  "\n"
  "  __CPROVER_HIDE:;\n"
  "  return malloc(malloc_size);\n"
  "}\n"
  "\n"
},
{ "posix_memalign",
  "#line 1 \"<builtin-library-posix_memalign>\"\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef posix_memalign\n"
  "\n"
  "void *malloc(__CPROVER_size_t malloc_size);\n"
  "int posix_memalign(\n"
  "  void **ptr,\n"
  "  __CPROVER_size_t alignment,\n"
  "  __CPROVER_size_t size)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "\n"
  "  __CPROVER_size_t multiplier = alignment / sizeof(void *);\n"
  "  // Modeling the posix_memalign checks on alignment.\n"
  "  if(\n"
  "    alignment % sizeof(void *) != 0 || ((multiplier) & (multiplier - 1)) != 0 ||\n"
  "    alignment == 0)\n"
  "  {\n"
  "    return EINVAL;\n"
  "  }\n"
  "  // The address of the allocated memory is supposed to be aligned with\n"
  "  // alignment. As cbmc doesn't model address alignment,\n"
  "  // assuming MALLOC_ALIGNMENT = MAX_INT_VALUE seems fair.\n"
  "  // As _mid_memalign simplifies for alignment <= MALLOC_ALIGNMENT\n"
  "  // to a malloc call, it should be sound, if we do it too.\n"
  "\n"
  "  void *tmp = malloc(size);\n"
  "  if(tmp != (void *)0)\n"
  "  {\n"
  "    *ptr = tmp;\n"
  "    return 0;\n"
  "  }\n"
  "  return ENOMEM;\n"
  "}\n"
  "\n"
},
{ "random",
  "#line 1 \"<builtin-library-random>\"\n"
  "\n"
  "long __VERIFIER_nondet_long();\n"
  "\n"
  "long random(void)\n"
  "{\n"
  "  // We return a non-deterministic value instead of a random one.\n"
  "  __CPROVER_HIDE:;\n"
  "  long result=__VERIFIER_nondet_long();\n"
  "  __CPROVER_assume(result>=0 && result<=2147483647);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "rand",
  "#line 1 \"<builtin-library-rand>\"\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int rand(void)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  // We return a non-deterministic value instead of a random one.\n"
  "  int result = __VERIFIER_nondet_int();\n"
  "  __CPROVER_assume(result >= 0);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "rand_r",
  "#line 1 \"<builtin-library-rand_r>\"\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int rand_r(unsigned int *seed)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  // We return a non-deterministic value instead of a random one.\n"
  "  (void)*seed;\n"
  "  int result = __VERIFIER_nondet_int();\n"
  "  __CPROVER_assume(result >= 0);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "__CPROVER_deallocate",
  "#line 1 \"<builtin-library-__CPROVER_deallocate>\"\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "void __CPROVER_deallocate(void *ptr)\n"
  "{\n"
  "  if(__VERIFIER_nondet___CPROVER_bool())\n"
  "    __CPROVER_deallocated = ptr;\n"
  "}\n"
},
{ "__builtin___strcpy_chk",
  "#line 1 \"<builtin-library-__builtin___strcpy_chk>\"\n"
  "\n"
  "char *__builtin___strcpy_chk(char *dst, const char *src, __CPROVER_size_t s)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(src), \"strcpy zero-termination of 2nd argument\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_buffer_size(dst) > __CPROVER_zero_string_length(src),\n"
  "    \"strcpy buffer overflow\");\n"
  "  __CPROVER_precondition(\n"
  "    s == ~(__CPROVER_size_t)0 || __CPROVER_buffer_size(dst) == s,\n"
  "    \"builtin object size\");\n"
  "  dst[__CPROVER_zero_string_length(src)] = 0;\n"
  "  __CPROVER_is_zero_string(dst) = 1;\n"
  "  __CPROVER_zero_string_length(dst) = __CPROVER_zero_string_length(src);\n"
  "#else\n"
  "  // __CPROVER_precondition(\n"
  "  //   __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src),\n"
  "  //   \"strcpy src/dst overlap\");\n"
  "  __CPROVER_size_t i = 0;\n"
  "  char ch;\n"
  "  do\n"
  "  {\n"
  "    ch = src[i];\n"
  "    dst[i] = ch;\n"
  "    i++;\n"
  "  } while(i < s && ch != (char)0);\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "__builtin___strcat_chk",
  "#line 1 \"<builtin-library-__builtin___strcat_chk>\"\n"
  "\n"
  "__inline char *__builtin___strcat_chk(char *dst, const char *src, __CPROVER_size_t s)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_size_t new_size;\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(dst), \"strcat zero-termination of 1st argument\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(src), \"strcat zero-termination of 2nd argument\");\n"
  "  __CPROVER_precondition(\n"
  "    s == ~(__CPROVER_size_t)0 || __CPROVER_buffer_size(dst) == s,\n"
  "    \"builtin object size\");\n"
  "  new_size =\n"
  "    __CPROVER_zero_string_length(dst) + __CPROVER_zero_string_length(src);\n"
  "  __CPROVER_assert(\n"
  "    __CPROVER_buffer_size(dst) > new_size, \"strcat buffer overflow\");\n"
  "  __CPROVER_size_t old_size = __CPROVER_zero_string_length(dst);\n"
  "  //\"  for(size_t i=0; i<__CPROVER_zero_string_length(src); i++)\n"
  "  //\"    dst[old_size+i];\n"
  "  dst[new_size] = 0;\n"
  "  __CPROVER_is_zero_string(dst) = 1;\n"
  "  __CPROVER_zero_string_length(dst) = new_size;\n"
  "#else\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src),\n"
  "    \"strcat src/dst overlap\");\n"
  "  __CPROVER_size_t i = 0;\n"
  "  while(dst[i] != 0)\n"
  "    i++;\n"
  "\n"
  "  __CPROVER_size_t j = 0;\n"
  "  char ch = 1;\n"
  "  for(; i < s && ch != (char)0; ++i, ++j)\n"
  "  {\n"
  "    ch = src[j];\n"
  "    dst[i] = ch;\n"
  "  }\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "__builtin___strncat_chk",
  "#line 1 \"<builtin-library-__builtin___strncat_chk>\"\n"
  "\n"
  "__inline char *__builtin___strncat_chk(\n"
  "  char *dst, const char *src, __CPROVER_size_t n, __CPROVER_size_t s)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_size_t additional, new_size;\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(dst), \"strncat zero-termination of 1st argument\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(src) || __CPROVER_buffer_size(src) >= n,\n"
  "    \"strncat zero-termination of 2nd argument\");\n"
  "  __CPROVER_precondition(\n"
  "    s == ~(__CPROVER_size_t)0 || __CPROVER_buffer_size(dst) == s,\n"
  "    \"builtin object size\");\n"
  "  additional = (n < __CPROVER_zero_string_length(src))\n"
  "                 ? n\n"
  "                 : __CPROVER_zero_string_length(src);\n"
  "  new_size = __CPROVER_is_zero_string(dst) + additional;\n"
  "  __CPROVER_assert(\n"
  "    __CPROVER_buffer_size(dst) > new_size, \"strncat buffer overflow\");\n"
  "  __CPROVER_size_t dest_len = __CPROVER_zero_string_length(dst);\n"
  "  __CPROVER_size_t i;\n"
  "  for(i = 0; i < n && i < __CPROVER_zero_string_length(src); i++)\n"
  "    dst[dest_len + i] = src[i];\n"
  "  dst[dest_len + i] = 0;\n"
  "  __CPROVER_is_zero_string(dst) = 1;\n"
  "  __CPROVER_zero_string_length(dst) = new_size;\n"
  "#else\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src),\n"
  "    \"strncat src/dst overlap\");\n"
  "\n"
  "  __CPROVER_size_t i = 0;\n"
  "  while(dst[i] != 0)\n"
  "    i++;\n"
  "\n"
  "  __CPROVER_size_t j = 0;\n"
  "  char ch = 1;\n"
  "  for(; i < s && j < n && ch != (char)0; ++i, ++j)\n"
  "  {\n"
  "    ch = src[j];\n"
  "    dst[i] = ch;\n"
  "  }\n"
  "  if(ch != (char)0)\n"
  "    dst[i] = '\\0';\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strcpy",
  "#line 1 \"<builtin-library-strcpy>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strcpy\n"
  "\n"
  "char *strcpy(char *dst, const char *src)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(src), \"strcpy zero-termination of 2nd argument\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_buffer_size(dst) > __CPROVER_zero_string_length(src),\n"
  "    \"strcpy buffer overflow\");\n"
  "  dst[__CPROVER_zero_string_length(src)] = 0;\n"
  "  __CPROVER_is_zero_string(dst) = 1;\n"
  "  __CPROVER_zero_string_length(dst) = __CPROVER_zero_string_length(src);\n"
  "#else\n"
  "  // __CPROVER_precondition(\n"
  "  //   __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src),\n"
  "  //   \"strcpy src/dst overlap\");\n"
  "  __CPROVER_size_t i = 0;\n"
  "  char ch;\n"
  "  do\n"
  "  {\n"
  "    ch = src[i];\n"
  "    dst[i] = ch;\n"
  "    i++;\n"
  "  } while(ch != (char)0);\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strncpy",
  "#line 1 \"<builtin-library-strncpy>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strncpy\n"
  "\n"
  "char *strncpy(char *dst, const char *src, size_t n)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(src), \"strncpy zero-termination of 2nd argument\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_buffer_size(dst) >= n, \"strncpy buffer overflow\");\n"
  "  __CPROVER_is_zero_string(dst) = __CPROVER_zero_string_length(src) < n;\n"
  "  __CPROVER_zero_string_length(dst) = __CPROVER_zero_string_length(src);\n"
  "#else\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src) ||\n"
  "      (src >= dst + n) || (dst >= src + n),\n"
  "    \"strncpy src/dst overlap\");\n"
  "  __CPROVER_size_t i = 0;\n"
  "  char ch;\n"
  "  _Bool end;\n"
  "\n"
  "  // We use a single loop to make bounds checking etc easier.\n"
  "  // Note that strncpy _always_ writes 'n' characters into 'dst'.\n"
  "  for(end = 0; i < n; i++)\n"
  "  {\n"
  "    ch = end ? 0 : src[i];\n"
  "    dst[i] = ch;\n"
  "    end = end || ch == (char)0;\n"
  "  }\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "__builtin___strncpy_chk",
  "#line 1 \"<builtin-library-__builtin___strncpy_chk>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "char *__builtin___strncpy_chk(\n"
  "  char *dst,\n"
  "  const char *src,\n"
  "  size_t n,\n"
  "  size_t object_size)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(src), \"strncpy zero-termination of 2nd argument\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_buffer_size(dst) >= n, \"strncpy buffer overflow\");\n"
  "  __CPROVER_precondition(\n"
  "    object_size == ~(size_t)0 || __CPROVER_buffer_size(dst) == object_size,\n"
  "    \"strncpy object size\");\n"
  "  __CPROVER_is_zero_string(dst) = __CPROVER_zero_string_length(src) < n;\n"
  "  __CPROVER_zero_string_length(dst) = __CPROVER_zero_string_length(src);\n"
  "#else\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src) ||\n"
  "      (src >= dst + n) || (dst >= src + n),\n"
  "    \"strncpy src/dst overlap\");\n"
  "  __CPROVER_size_t i = 0;\n"
  "  char ch;\n"
  "  _Bool end;\n"
  "  (void)object_size;\n"
  "\n"
  "  // We use a single loop to make bounds checking etc easier.\n"
  "  // Note that strncpy _always_ writes 'n' characters into 'dst'.\n"
  "  for(end = 0; i < n; i++)\n"
  "  {\n"
  "    ch = end ? 0 : src[i];\n"
  "    dst[i] = ch;\n"
  "    end = end || ch == (char)0;\n"
  "  }\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strcat",
  "#line 1 \"<builtin-library-strcat>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strcat\n"
  "\n"
  "char *strcat(char *dst, const char *src)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_size_t new_size;\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(dst),\n"
  "                         \"strcat zero-termination of 1st argument\");\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(src),\n"
  "                         \"strcat zero-termination of 2nd argument\");\n"
  "  new_size=__CPROVER_zero_string_length(dst)+__CPROVER_zero_string_length(src);\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>new_size,\n"
  "                   \"strcat buffer overflow\");\n"
  "  __CPROVER_size_t old_size=__CPROVER_zero_string_length(dst);\n"
  "  //\"  for(size_t i=0; i<__CPROVER_zero_string_length(src); i++)\n"
  "  //\"    dst[old_size+i];\n"
  "  dst[new_size]=0;\n"
  "  __CPROVER_is_zero_string(dst)=1;\n"
  "  __CPROVER_zero_string_length(dst)=new_size;\n"
  "#else\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src),\n"
  "    \"strcat src/dst overlap\");\n"
  "  __CPROVER_size_t i = 0;\n"
  "  while(dst[i] != 0)\n"
  "    i++;\n"
  "\n"
  "  __CPROVER_size_t j = 0;\n"
  "  char ch = 1;\n"
  "  for(; ch != (char)0; ++i, ++j)\n"
  "  {\n"
  "    ch = src[j];\n"
  "    dst[i] = ch;\n"
  "  }\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strncat",
  "#line 1 \"<builtin-library-strncat>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strncat\n"
  "\n"
  "char *strncat(char *dst, const char *src, size_t n)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_size_t additional, new_size;\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(dst), \"strncat zero-termination of 1st argument\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_is_zero_string(src) || __CPROVER_buffer_size(src) >= n,\n"
  "    \"strncat zero-termination of 2nd argument\");\n"
  "  additional = (n < __CPROVER_zero_string_length(src))\n"
  "                 ? n\n"
  "                 : __CPROVER_zero_string_length(src);\n"
  "  new_size = __CPROVER_is_zero_string(dst) + additional;\n"
  "  __CPROVER_assert(\n"
  "    __CPROVER_buffer_size(dst) > new_size, \"strncat buffer overflow\");\n"
  "  __CPROVER_size_t dest_len = __CPROVER_zero_string_length(dst);\n"
  "  __CPROVER_size_t i;\n"
  "  for(i = 0; i < n && i < __CPROVER_zero_string_length(src); i++)\n"
  "    dst[dest_len + i] = src[i];\n"
  "  dst[dest_len + i] = 0;\n"
  "  __CPROVER_is_zero_string(dst) = 1;\n"
  "  __CPROVER_zero_string_length(dst) = new_size;\n"
  "#else\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src) ||\n"
  "      (src >= dst + n) || (dst >= src + n),\n"
  "    \"strncat src/dst overlap\");\n"
  "\n"
  "  __CPROVER_size_t i = 0;\n"
  "  while(dst[i] != 0)\n"
  "    i++;\n"
  "\n"
  "  __CPROVER_size_t j = 0;\n"
  "  char ch = 1;\n"
  "  for(; j < n && ch != (char)0; ++i, ++j)\n"
  "  {\n"
  "    ch = src[j];\n"
  "    dst[i] = ch;\n"
  "  }\n"
  "  if(ch != (char)0)\n"
  "    dst[i] = '\\0';\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strcmp",
  "#line 1 \"<builtin-library-strcmp>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strcmp\n"
  "\n"
  "int strcmp(const char *s1, const char *s2)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  int retval;\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s1),\n"
  "                         \"strcmp zero-termination of 1st argument\");\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s2),\n"
  "                         \"strcmp zero-termination of 2nd argument\");\n"
  "\n"
  "  if(__CPROVER_zero_string_length(s1) != __CPROVER_zero_string_length(s2))\n"
  "    __CPROVER_assume(retval!=0);\n"
  "\n"
  "  return retval;\n"
  "#else\n"
  "  __CPROVER_size_t i=0;\n"
  "  unsigned char ch1, ch2;\n"
  "  do\n"
  "  {\n"
  "#  pragma CPROVER check push\n"
  "#  pragma CPROVER check disable \"conversion\"\n"
  "    ch1=s1[i];\n"
  "    ch2=s2[i];\n"
  "#  pragma CPROVER check pop\n"
  "\n"
  "    if(ch1==ch2)\n"
  "    {\n"
  "    }\n"
  "    else if(ch1<ch2)\n"
  "      return -1;\n"
  "    else\n"
  "      return 1;\n"
  "\n"
  "    i++;\n"
  "  }\n"
  "  while(ch1!=0 && ch2!=0);\n"
  "  return 0;\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "strcasecmp",
  "#line 1 \"<builtin-library-strcasecmp>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strcasecmp\n"
  "\n"
  "int strcasecmp(const char *s1, const char *s2)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  int retval;\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s1),\n"
  "                         \"strcasecmp zero-termination of 1st argument\");\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s2),\n"
  "                         \"strcasecmp zero-termination of 2nd argument\");\n"
  "\n"
  "  if(__CPROVER_zero_string_length(s1) != __CPROVER_zero_string_length(s2))\n"
  "    __CPROVER_assume(retval!=0);\n"
  "\n"
  "  return retval;\n"
  "#else\n"
  "  __CPROVER_size_t i=0;\n"
  "  unsigned char ch1, ch2;\n"
  "  do\n"
  "  {\n"
  "#  pragma CPROVER check push\n"
  "#  pragma CPROVER check disable \"conversion\"\n"
  "    ch1=s1[i];\n"
  "    ch2=s2[i];\n"
  "#  pragma CPROVER check pop\n"
  "\n"
  "    if(ch1>='A' && ch1<='Z') ch1+=('a'-'A');\n"
  "    if(ch2>='A' && ch2<='Z') ch2+=('a'-'A');\n"
  "\n"
  "    if(ch1==ch2)\n"
  "    {\n"
  "    }\n"
  "    else if(ch1<ch2)\n"
  "      return -1;\n"
  "    else\n"
  "      return 1;\n"
  "\n"
  "    i++;\n"
  "  }\n"
  "  while(ch1!=0 && ch2!=0);\n"
  "  return 0;\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "strncmp",
  "#line 1 \"<builtin-library-strncmp>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strncmp\n"
  "\n"
  "int strncmp(const char *s1, const char *s2, size_t n)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s1) ||\n"
  "                         __CPROVER_buffer_size(s1)>=n,\n"
  "                         \"strncmp zero-termination of 1st argument\");\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s2) ||\n"
  "                         __CPROVER_buffer_size(s2)>=n,\n"
  "                         \"strncmp zero-termination of 2nd argument\");\n"
  "#else\n"
  "  __CPROVER_size_t i=0;\n"
  "  unsigned char ch1, ch2;\n"
  "  if(n == 0)\n"
  "    return 0;\n"
  "  do\n"
  "  {\n"
  "#  pragma CPROVER check push\n"
  "#  pragma CPROVER check disable \"conversion\"\n"
  "    ch1=s1[i];\n"
  "    ch2=s2[i];\n"
  "#  pragma CPROVER check pop\n"
  "\n"
  "    if(ch1==ch2)\n"
  "    {\n"
  "    }\n"
  "    else if(ch1<ch2)\n"
  "      return -1;\n"
  "    else\n"
  "      return 1;\n"
  "\n"
  "    i++;\n"
  "  }\n"
  "  while(ch1!=0 && ch2!=0 && i<n);\n"
  "  return 0;\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "strncasecmp",
  "#line 1 \"<builtin-library-strncasecmp>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strncasecmp\n"
  "\n"
  "int strncasecmp(const char *s1, const char *s2, size_t n)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  int retval;\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s1),\n"
  "                         \"strncasecmp zero-termination of 1st argument\");\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s2),\n"
  "                         \"strncasecmp zero-termination of 2nd argument\");\n"
  "  return retval;\n"
  "#else\n"
  "  __CPROVER_size_t i=0;\n"
  "  unsigned char ch1, ch2;\n"
  "  if(n == 0)\n"
  "    return 0;\n"
  "  do\n"
  "  {\n"
  "#  pragma CPROVER check push\n"
  "#  pragma CPROVER check disable \"conversion\"\n"
  "    ch1=s1[i];\n"
  "    ch2=s2[i];\n"
  "#  pragma CPROVER check pop\n"
  "\n"
  "    if(ch1>='A' && ch1<='Z') ch1+=('a'-'A');\n"
  "    if(ch2>='A' && ch2<='Z') ch2+=('a'-'A');\n"
  "\n"
  "    if(ch1==ch2)\n"
  "    {\n"
  "    }\n"
  "    else if(ch1<ch2)\n"
  "      return -1;\n"
  "    else\n"
  "      return 1;\n"
  "\n"
  "    i++;\n"
  "  }\n"
  "  while(ch1!=0 && ch2!=0 && i<n);\n"
  "  return 0;\n"
  "#endif\n"
  "}\n"
  "\n"
},
{ "strlen",
  "#line 1 \"<builtin-library-strlen>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strlen\n"
  "\n"
  "size_t strlen(const char *s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s),\n"
  "                         \"strlen zero-termination\");\n"
  "  return __CPROVER_zero_string_length(s);\n"
  "  #else\n"
  "  __CPROVER_size_t len=0;\n"
  "  while(s[len]!=0) len++;\n"
  "  return len;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strdup",
  "#line 1 \"<builtin-library-strdup>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strdup\n"
  "#undef strcpy\n"
  "\n"
  "char *strdup(const char *str)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_size_t bufsz;\n"
  "  bufsz=(strlen(str)+1);\n"
  "  char *cpy = (char *)calloc(bufsz * sizeof(char), sizeof(char));\n"
  "  if(cpy==((void *)0)) return 0;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assume(__CPROVER_buffer_size(cpy)==bufsz);\n"
  "  #endif\n"
  "  strcpy(cpy, str);\n"
  "  return cpy;\n"
  "}\n"
  "\n"
},
{ "memcpy",
  "#line 1 \"<builtin-library-memcpy>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memcpy\n"
  "\n"
  "void *memcpy(void *dst, const void *src, size_t n)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_buffer_size(src) >= n, \"memcpy buffer overflow\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_buffer_size(dst) >= n, \"memcpy buffer overflow\");\n"
  "  //  for(size_t i=0; i<n ; i++) dst[i]=src[i];\n"
  "  if(__CPROVER_is_zero_string(src) && n > __CPROVER_zero_string_length(src))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(dst) = 1;\n"
  "    __CPROVER_zero_string_length(dst) = __CPROVER_zero_string_length(src);\n"
  "  }\n"
  "  else if(!(__CPROVER_is_zero_string(dst) &&\n"
  "            n <= __CPROVER_zero_string_length(dst)))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(dst) = 0;\n"
  "  }\n"
  "\n"
  "#else\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src) ||\n"
  "      ((const char *)src >= (const char *)dst + n) ||\n"
  "      ((const char *)dst >= (const char *)src + n),\n"
  "    \"memcpy src/dst overlap\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_r_ok(src, n), \"memcpy source region readable\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_w_ok(dst, n), \"memcpy destination region writeable\");\n"
  "\n"
  "  if(n > 0)\n"
  "  {\n"
  "    //for(__CPROVER_size_t i=0; i<n ; i++) ((char *)dst)[i]=((const char *)src)[i];\n"
  "    char src_n[n];\n"
  "    __CPROVER_array_copy(src_n, (char *)src);\n"
  "    __CPROVER_array_replace((char *)dst, src_n);\n"
  "  }\n"
  "#endif\n"
  "\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "__builtin___memcpy_chk",
  "#line 1 \"<builtin-library-__builtin___memcpy_chk>\"\n"
  "\n"
  "void *__builtin___memcpy_chk(void *dst, const void *src, __CPROVER_size_t n, __CPROVER_size_t size)\n"
  "{\n"
  "__CPROVER_HIDE:\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_buffer_size(src) >= n, \"memcpy buffer overflow\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_buffer_size(dst) >= n, \"memcpy buffer overflow\");\n"
  "  __CPROVER_precondition(\n"
  "    size == ~(__CPROVER_size_t)0 || __CPROVER_buffer_size(dst) == size,\n"
  "    \"builtin object size\");\n"
  "  //  for(size_t i=0; i<n ; i++) dst[i]=src[i];\n"
  "  if(__CPROVER_is_zero_string(src) && n > __CPROVER_zero_string_length(src))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(dst) = 1;\n"
  "    __CPROVER_zero_string_length(dst) = __CPROVER_zero_string_length(src);\n"
  "  }\n"
  "  else if(!(__CPROVER_is_zero_string(dst) &&\n"
  "            n <= __CPROVER_zero_string_length(dst)))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(dst) = 0;\n"
  "  }\n"
  "#else\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_POINTER_OBJECT(dst) != __CPROVER_POINTER_OBJECT(src) ||\n"
  "      ((const char *)src >= (const char *)dst + n) ||\n"
  "      ((const char *)dst >= (const char *)src + n),\n"
  "    \"memcpy src/dst overlap\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_r_ok(src, n), \"memcpy source region readable\");\n"
  "  __CPROVER_precondition(\n"
  "    __CPROVER_w_ok(dst, n), \"memcpy destination region writeable\");\n"
  "  (void)size;\n"
  "\n"
  "  if(n > 0)\n"
  "  {\n"
  "    //for(__CPROVER_size_t i=0; i<n ; i++) ((char *)dst)[i]=((const char *)src)[i];\n"
  "    char src_n[n];\n"
  "    __CPROVER_array_copy(src_n, (char *)src);\n"
  "    __CPROVER_array_replace((char *)dst, src_n);\n"
  "  }\n"
  "#endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "memset",
  "#line 1 \"<builtin-library-memset>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memset\n"
  "\n"
  "void *memset(void *s, int c, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_buffer_size(s)>=n,\n"
  "                         \"memset buffer overflow\");\n"
  "  //  for(size_t i=0; i<n ; i++) s[i]=c;\n"
  "  if(__CPROVER_is_zero_string(s) &&\n"
  "     n > __CPROVER_zero_string_length(s))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "  }\n"
  "  else if(c==0)\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "    __CPROVER_zero_string_length(s)=0;\n"
  "  }\n"
  "  else\n"
  "    __CPROVER_is_zero_string(s)=0;\n"
  "  #else\n"
  "  __CPROVER_precondition(__CPROVER_w_ok(s, n),\n"
  "                         \"memset destination region writeable\");\n"
  "\n"
  "  if(n > 0)\n"
  "  {\n"
  "    //char *sp=s;\n"
  "    //for(__CPROVER_size_t i=0; i<n ; i++) sp[i]=c;\n"
  "    unsigned char s_n[n];\n"
  "    __CPROVER_array_set(s_n, (unsigned char)c);\n"
  "    __CPROVER_array_replace((unsigned char *)s, s_n);\n"
  "  }\n"
  "  #endif\n"
  "  return s;\n"
  "}\n"
  "\n"
},
{ "__builtin_memset",
  "#line 1 \"<builtin-library-__builtin_memset>\"\n"
  "\n"
  "void *__builtin_memset(void *s, int c, __CPROVER_size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_buffer_size(s)>=n,\n"
  "                         \"memset buffer overflow\");\n"
  "  //  for(size_t i=0; i<n ; i++) s[i]=c;\n"
  "  if(__CPROVER_is_zero_string(s) &&\n"
  "     n > __CPROVER_zero_string_length(s))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "  }\n"
  "  else if(c==0)\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "    __CPROVER_zero_string_length(s)=0;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=0;\n"
  "  }\n"
  "  #else\n"
  "  __CPROVER_precondition(__CPROVER_w_ok(s, n),\n"
  "                         \"memset destination region writeable\");\n"
  "\n"
  "  if(n > 0)\n"
  "  {\n"
  "    //char *sp=s;\n"
  "    //for(__CPROVER_size_t i=0; i<n ; i++) sp[i]=c;\n"
  "    unsigned char s_n[n];\n"
  "    __CPROVER_array_set(s_n, (unsigned char)c);\n"
  "    __CPROVER_array_replace((unsigned char *)s, s_n);\n"
  "  }\n"
  "  #endif\n"
  "  return s;\n"
  "}\n"
  "\n"
},
{ "__builtin___memset_chk",
  "#line 1 \"<builtin-library-__builtin___memset_chk>\"\n"
  "\n"
  "void *__builtin___memset_chk(void *s, int c, __CPROVER_size_t n, __CPROVER_size_t size)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "#ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_buffer_size(s)>=n,\n"
  "                         \"memset buffer overflow\");\n"
  "  __CPROVER_precondition(\n"
  "    size == ~(__CPROVER_size_t)0 || __CPROVER_buffer_size(s) == size,\n"
  "    \"builtin object size\");\n"
  "  //  for(size_t i=0; i<n ; i++) s[i]=c;\n"
  "  if(__CPROVER_is_zero_string(s) &&\n"
  "     n > __CPROVER_zero_string_length(s))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "  }\n"
  "  else if(c==0)\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "    __CPROVER_zero_string_length(s)=0;\n"
  "  }\n"
  "  else\n"
  "    __CPROVER_is_zero_string(s)=0;\n"
  "#else\n"
  "  __CPROVER_precondition(__CPROVER_w_ok(s, n),\n"
  "                         \"memset destination region writeable\");\n"
  "  (void)size;\n"
  "\n"
  "  if(n > 0)\n"
  "  {\n"
  "    //char *sp=s;\n"
  "    //for(__CPROVER_size_t i=0; i<n ; i++) sp[i]=c;\n"
  "    unsigned char s_n[n];\n"
  "    __CPROVER_array_set(s_n, (unsigned char)c);\n"
  "    __CPROVER_array_replace((unsigned char *)s, s_n);\n"
  "  }\n"
  "#endif\n"
  "  return s;\n"
  "}\n"
  "\n"
},
{ "memmove",
  "#line 1 \"<builtin-library-memmove>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memmove\n"
  "\n"
  "void *memmove(void *dest, const void *src, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_buffer_size(src)>=n,\n"
  "                         \"memmove buffer overflow\");\n"
  "  // dst = src (with overlap allowed)\n"
  "  if(__CPROVER_is_zero_string(src) &&\n"
  "     n > __CPROVER_zero_string_length(src))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(src)=1;\n"
  "    __CPROVER_zero_string_length(dest)=__CPROVER_zero_string_length(src);\n"
  "  }\n"
  "  else\n"
  "    __CPROVER_is_zero_string(dest)=0;\n"
  "  #else\n"
  "  __CPROVER_precondition(__CPROVER_r_ok(src, n),\n"
  "                         \"memmove source region readable\");\n"
  "  __CPROVER_precondition(__CPROVER_w_ok(dest, n),\n"
  "                         \"memmove destination region writeable\");\n"
  "\n"
  "  if(n > 0)\n"
  "  {\n"
  "    char src_n[n];\n"
  "    __CPROVER_array_copy(src_n, (char *)src);\n"
  "    __CPROVER_array_replace((char *)dest, src_n);\n"
  "  }\n"
  "  #endif\n"
  "  return dest;\n"
  "}\n"
  "\n"
},
{ "__builtin___memmove_chk",
  "#line 1 \"<builtin-library-__builtin___memmove_chk>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memmove\n"
  "\n"
  "void *__builtin___memmove_chk(void *dest, const void *src, size_t n, __CPROVER_size_t size)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_buffer_size(src)>=n,\n"
  "                         \"memmove buffer overflow\");\n"
  "  __CPROVER_precondition(\n"
  "    size == ~(__CPROVER_size_t)0 || __CPROVER_buffer_size(dest) == size,\n"
  "    \"builtin object size\");\n"
  "  // dst = src (with overlap allowed)\n"
  "  if(__CPROVER_is_zero_string(src) &&\n"
  "     n > __CPROVER_zero_string_length(src))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(src)=1;\n"
  "    __CPROVER_zero_string_length(dest)=__CPROVER_zero_string_length(src);\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_is_zero_string(dest)=0;\n"
  "  }\n"
  "  #else\n"
  "  __CPROVER_precondition(__CPROVER_r_ok(src, n),\n"
  "                         \"memmove source region readable\");\n"
  "  __CPROVER_precondition(__CPROVER_w_ok(dest, n),\n"
  "                         \"memmove destination region writeable\");\n"
  "  (void)size;\n"
  "\n"
  "  if(n > 0)\n"
  "  {\n"
  "    char src_n[n];\n"
  "    __CPROVER_array_copy(src_n, (char *)src);\n"
  "    __CPROVER_array_replace((char *)dest, src_n);\n"
  "  }\n"
  "  #endif\n"
  "  return dest;\n"
  "}\n"
  "\n"
},
{ "memcmp",
  "#line 1 \"<builtin-library-memcmp>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memcmp\n"
  "\n"
  "int memcmp(const void *s1, const void *s2, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int res=0;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_buffer_size(s1)>=n,\n"
  "                         \"memcmp buffer overflow of 1st argument\");\n"
  "  __CPROVER_precondition(__CPROVER_buffer_size(s2)>=n,\n"
  "                         \"memcmp buffer overflow of 2nd argument\");\n"
  "  #else\n"
  "  __CPROVER_precondition(__CPROVER_r_ok(s1, n),\n"
  "                         \"memcmp region 1 readable\");\n"
  "  __CPROVER_precondition(__CPROVER_r_ok(s2, n),\n"
  "                         \"memcpy region 2 readable\");\n"
  "\n"
  "  const unsigned char *sc1=s1, *sc2=s2;\n"
  "  for(; n!=0; n--)\n"
  "  {\n"
  "    res = (*sc1++) - (*sc2++);\n"
  "    if (res != 0)\n"
  "      return res;\n"
  "  }\n"
  "  #endif\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "strchr",
  "#line 1 \"<builtin-library-strchr>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strchr\n"
  "\n"
  "char *strchr(const char *src, int c)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(src),\n"
  "                         \"strchr zero-termination of string argument\");\n"
  "  __CPROVER_bool found;\n"
  "  __CPROVER_size_t i;\n"
  "  return found?src+i:0;\n"
  "  #else\n"
  "  for(__CPROVER_size_t i=0; ; i++)\n"
  "  {\n"
  "    if(src[i]==(char)c)\n"
  "      return ((char *)src)+i; // cast away const-ness\n"
  "    if(src[i]==0) break;\n"
  "  }\n"
  "  return 0;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strrchr",
  "#line 1 \"<builtin-library-strrchr>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strchr\n"
  "\n"
  "char *strrchr(const char *src, int c)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(src),\n"
  "                         \"strrchr zero-termination of string argument\");\n"
  "  __CPROVER_bool found;\n"
  "  __CPROVER_size_t i;\n"
  "  return found?((char *)src)+i:0;\n"
  "  #else\n"
  "  char *res=0;\n"
  "  for(__CPROVER_size_t i=0; ; i++)\n"
  "  {\n"
  "    if(src[i]==(char)c) res=((char *)src)+i;\n"
  "    if(src[i]==0) break;\n"
  "  }\n"
  "  return res;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strerror",
  "#line 1 \"<builtin-library-strerror>\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "char *strerror(int errnum)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)errnum;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_event(\"invalidate_pointer\", \"strerror_result\");\n"
  "  char *strerror_result;\n"
  "  __CPROVER_set_must(strerror_result, \"strerror_result\");\n"
  "  return strerror_result;\n"
  "  #else\n"
  "  static char strerror_result[1];\n"
  "  return strerror_result;\n"
  "  #endif\n"
  "}\n"
},
{ "bzero",
  "#line 1 \"<builtin-library-bzero>\"\n"
  "\n"
  "void bzero(void *s, __CPROVER_size_t n)\n"
  "{\n"
  "  for(__CPROVER_size_t i=0; i<n; i++)\n"
  "    ((char *)s)[i]=0;\n"
  "}\n"
},
{ "openlog",
  "#line 1 \"<builtin-library-openlog>\"\n"
  "\n"
  "#ifndef __CPROVER_SYSLOG_H_INCLUDED\n"
  "#include <syslog.h>\n"
  "#define __CPROVER_SYSLOG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void openlog(const char *ident, int option, int facility)\n"
  "{\n"
  "  (void)*ident;\n"
  "  (void)option;\n"
  "  (void)facility;\n"
  "}\n"
  "\n"
},
{ "closelog",
  "#line 1 \"<builtin-library-closelog>\"\n"
  "\n"
  "#ifndef __CPROVER_SYSLOG_H_INCLUDED\n"
  "#include <syslog.h>\n"
  "#define __CPROVER_SYSLOG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void closelog(void)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "syslog",
  "#line 1 \"<builtin-library-syslog>\"\n"
  "\n"
  "#ifndef __CPROVER_SYSLOG_H_INCLUDED\n"
  "#include <syslog.h>\n"
  "#define __CPROVER_SYSLOG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void syslog(int priority, const char *format, ...)\n"
  "{\n"
  "  (void)priority;\n"
  "  (void)*format;\n"
  "}\n"
},
{ "thrd_create",
  "#line 1 \"<builtin-library-thrd_create>\"\n"
  "\n"
  "// following http://en.cppreference.com/w/c/thread\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int thrd_create(thrd_t *thr, thrd_start_t func, void *arg)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_equal",
  "#line 1 \"<builtin-library-thrd_equal>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int thrd_equal( thrd_t lhs, thrd_t rhs )\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_current",
  "#line 1 \"<builtin-library-thrd_current>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "thrd_t thrd_current()\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_sleep",
  "#line 1 \"<builtin-library-thrd_sleep>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int thrd_sleep(const struct timespec* time_point,\n"
  "               struct timespec* remaining)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_yield",
  "#line 1 \"<builtin-library-thrd_yield>\"\n"
  "\n"
  "void thrd_yield()\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_exit",
  "#line 1 \"<builtin-library-thrd_exit>\"\n"
  "\n"
  "void thrd_exit(int res)\n"
  "{\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "\n"
},
{ "mtx_init",
  "#line 1 \"<builtin-library-mtx_init>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_init( mtx_t* mutex, int type )\n"
  "{\n"
  "}\n"
  "\n"
},
{ "mtx_lock",
  "#line 1 \"<builtin-library-mtx_lock>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_lock(mtx_t* mutex)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "mtx_timedlock",
  "#line 1 \"<builtin-library-mtx_timedlock>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_timedlock(mtx_t *restrict mutex,\n"
  "                  const struct timespec *restrict time_point)\n"
  "{\n"
  "\n"
  "}\n"
  "\n"
},
{ "mtx_trylock",
  "#line 1 \"<builtin-library-mtx_trylock>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_trylock(mtx_t *mutex)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "mtx_unlock",
  "#line 1 \"<builtin-library-mtx_unlock>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_unlock(mtx_t *mutex)\n"
  "{\n"
  "\n"
  "}\n"
  "\n"
},
{ "mtx_destroy",
  "#line 1 \"<builtin-library-mtx_destroy>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void mtx_destroy(mtx_t *mutex)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "call_once",
  "#line 1 \"<builtin-library-call_once>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void call_once(once_flag* flag, void (*func)(void))\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_init",
  "#line 1 \"<builtin-library-cnd_init>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_init(cnd_t* cond)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_signal",
  "#line 1 \"<builtin-library-cnd_signal>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_signal(cnd_t *cond)\n"
  "{\n"
  "\n"
  "}\n"
  "\n"
},
{ "cnd_broadcast",
  "#line 1 \"<builtin-library-cnd_broadcast>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_broadcast(cnd_t *cond)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_wait",
  "#line 1 \"<builtin-library-cnd_wait>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_wait(cnd_t* cond, mtx_t* mutex)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_timedwait",
  "#line 1 \"<builtin-library-cnd_timedwait>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_timedwait(cnd_t* restrict cond, mtx_t* restrict mutex,\n"
  "                  const struct timespec* restrict time_point)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_destroy",
  "#line 1 \"<builtin-library-cnd_destroy>\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void cnd_destroy(cnd_t* cond)\n"
  "{\n"
  "}\n"
},
{ "time",
  "#line 1 \"<builtin-library-time>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef time\n"
  "\n"
  "time_t __VERIFIER_nondet_time_t();\n"
  "\n"
  "time_t time(time_t *tloc)\n"
  "{\n"
  "  time_t res=__VERIFIER_nondet_time_t();\n"
  "  if(tloc)\n"
  "    *tloc = res;\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "_time64",
  "#line 1 \"<builtin-library-_time64>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "#  ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#    include <time.h>\n"
  "#    define __CPROVER_TIME_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "time_t __VERIFIER_nondet_time_t();\n"
  "\n"
  "time_t _time64(time_t *tloc)\n"
  "{\n"
  "  time_t res = __VERIFIER_nondet_time_t();\n"
  "  if(tloc)\n"
  "    *tloc = res;\n"
  "  return res;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_time32",
  "#line 1 \"<builtin-library-_time32>\"\n"
  "\n"
  "#if defined(_WIN32) && defined(_USE_32BIT_TIME_T)\n"
  "\n"
  "#  ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#    include <time.h>\n"
  "#    define __CPROVER_TIME_H_INCLUDED\n"
  "#  endif\n"
  "\n"
  "__time32_t __VERIFIER_nondet_time32_t();\n"
  "\n"
  "__time32_t _time32(__time32_t *tloc)\n"
  "{\n"
  "  __time32_t res = __VERIFIER_nondet_time32_t();\n"
  "  if(tloc)\n"
  "    *tloc = res;\n"
  "  return res;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "gmtime",
  "#line 1 \"<builtin-library-gmtime>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef gmtime\n"
  "\n"
  "struct tm *gmtime(const time_t *clock)\n"
  "{\n"
  "  // not very general, may be too restrictive\n"
  "  // need to set the fields to something meaningful\n"
  "  (void)*clock;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_event(\"invalidate_pointer\", \"gmtime_result\");\n"
  "  struct tm *gmtime_result;\n"
  "  __CPROVER_set_must(gmtime_result, \"gmtime_result\");\n"
  "  return gmtime_result;\n"
  "  #else\n"
  "  static struct tm return_value;\n"
  "  return &return_value;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "gmtime_r",
  "#line 1 \"<builtin-library-gmtime_r>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef gmtime\n"
  "\n"
  "struct tm *gmtime_r(const time_t *clock, struct tm *result)\n"
  "{\n"
  "  // need to set the fields to something meaningful\n"
  "  (void)*clock;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "localtime",
  "#line 1 \"<builtin-library-localtime>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef localtime\n"
  "\n"
  "struct tm *localtime(const time_t *clock)\n"
  "{\n"
  "  // not very general, may be too restrictive\n"
  "  // need to set the fields to something meaningful\n"
  "  (void)*clock;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_event(\"invalidate_pointer\", \"localtime_result\");\n"
  "  struct tm *localtime_result;\n"
  "  __CPROVER_set_must(localtime_result, \"localtime_result\");\n"
  "  return localtime_result;\n"
  "  #else\n"
  "  static struct tm return_value;\n"
  "  return &return_value;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "localtime_r",
  "#line 1 \"<builtin-library-localtime_r>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef localtime\n"
  "\n"
  "struct tm *localtime_r(const time_t *clock, struct tm *result)\n"
  "{\n"
  "  // need to set the fields to something meaningful\n"
  "  (void)*clock;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "mktime",
  "#line 1 \"<builtin-library-mktime>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef mktime\n"
  "\n"
  "time_t __VERIFIER_nondet_time_t();\n"
  "\n"
  "time_t mktime(struct tm *timeptr)\n"
  "{\n"
  "  (void)*timeptr;\n"
  "  time_t result=__VERIFIER_nondet_time_t();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "timegm",
  "#line 1 \"<builtin-library-timegm>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef timegm\n"
  "\n"
  "time_t __VERIFIER_nondet_time_t();\n"
  "\n"
  "time_t timegm(struct tm *timeptr)\n"
  "{\n"
  "  (void)*timeptr;\n"
  "  time_t result=__VERIFIER_nondet_time_t();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "asctime",
  "#line 1 \"<builtin-library-asctime>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "char *asctime(const struct tm *timeptr)\n"
  "{\n"
  "  (void)*timeptr;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_event(\"invalidate_pointer\", \"asctime_result\");\n"
  "  char *asctime_result;\n"
  "  __CPROVER_set_must(asctime_result, \"asctime_result\");\n"
  "  return asctime_result;\n"
  "  #else\n"
  "  static char asctime_result[1];\n"
  "  return asctime_result;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "ctime",
  "#line 1 \"<builtin-library-ctime>\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "char *ctime(const time_t *clock)\n"
  "{\n"
  "  (void)*clock;\n"
  "  #ifdef __CPROVER_CUSTOM_BITVECTOR_ANALYSIS\n"
  "  __CPROVER_event(\"invalidate_pointer\", \"ctime_result\");\n"
  "  char *ctime_result;\n"
  "  __CPROVER_set_must(ctime_result, \"ctime_result\");\n"
  "  return ctime_result;\n"
  "  #else\n"
  "  static char ctime_result[1];\n"
  "  return ctime_result;\n"
  "  #endif\n"
  "}\n"
},
{ "sleep",
  "#line 1 \"<builtin-library-sleep>\"\n"
  "\n"
  "unsigned __VERIFIER_nondet_unsigned();\n"
  "\n"
  "unsigned int sleep(unsigned int seconds)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // do nothing, but return nondet value\n"
  "  unsigned remaining_time=__VERIFIER_nondet_unsigned();\n"
  "  __CPROVER_assume(remaining_time <= seconds);\n"
  "\n"
  "  return remaining_time;\n"
  "}\n"
  "\n"
},
{ "_sleep",
  "#line 1 \"<builtin-library-_sleep>\"\n"
  "\n"
  "unsigned int sleep(unsigned int seconds);\n"
  "\n"
  "unsigned int _sleep(unsigned int seconds)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return sleep(seconds);\n"
  "}\n"
  "\n"
},
{ "unlink",
  "#line 1 \"<builtin-library-unlink>\"\n"
  "\n"
  "int __VERIFIER_nondet_int();\n"
  "\n"
  "int unlink(const char *s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*s;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_precondition(__CPROVER_is_zero_string(s),\n"
  "                         \"unlink zero-termination\");\n"
  "  #endif\n"
  "  int retval=__VERIFIER_nondet_int();\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "pipe",
  "#line 1 \"<builtin-library-pipe>\"\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern struct __CPROVER_pipet __CPROVER_pipes[];\n"
  "// offset to make sure we don't collide with other fds\n"
  "extern const int __CPROVER_pipe_offset;\n"
  "extern unsigned __CPROVER_pipe_count;\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "int pipe(int fildes[2])\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "  if(error)\n"
  "  {\n"
  "    errno = __VERIFIER_nondet___CPROVER_bool() ? EMFILE : ENFILE;\n"
  "    return -1;\n"
  "  }\n"
  "\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assume(__CPROVER_pipe_offset%2==0);\n"
  "  __CPROVER_assume(__CPROVER_pipe_offset<=(int)(__CPROVER_pipe_offset+__CPROVER_pipe_count));\n"
  "  fildes[0]=__CPROVER_pipe_offset+__CPROVER_pipe_count;\n"
  "  fildes[1]=__CPROVER_pipe_offset+__CPROVER_pipe_count+1;\n"
  "  __CPROVER_pipes[__CPROVER_pipe_count].widowed=0;\n"
  "  __CPROVER_pipes[__CPROVER_pipe_count].next_avail=0;\n"
  "  __CPROVER_pipes[__CPROVER_pipe_count].next_unread=0;\n"
  "  __CPROVER_pipe_count+=2;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_assume(fildes[0]!=0 && fildes[0]!=1 && fildes[0]!=2);\n"
  "  __CPROVER_assume(fildes[1]!=0 && fildes[1]!=1 && fildes[1]!=2);\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "_pipe",
  "#line 1 \"<builtin-library-_pipe>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#undef pipe\n"
  "int pipe(int fildes[2]);\n"
  "\n"
  "int _pipe(int *pfds, unsigned int psize, int textmode)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  (void)psize;\n"
  "  (void)textmode;\n"
  "  return pipe(pfds);\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "close",
  "#line 1 \"<builtin-library-close>\"\n"
  "\n"
  "extern struct __CPROVER_pipet __CPROVER_pipes[];\n"
  "// offset to make sure we don't collide with other fds\n"
  "extern const int __CPROVER_pipe_offset;\n"
  "\n"
  "int close(int fildes)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if((fildes>=0 && fildes<=2) || fildes < __CPROVER_pipe_offset)\n"
  "    return 0;\n"
  "\n"
  "  int retval=-1;\n"
  "  fildes-=__CPROVER_pipe_offset;\n"
  "  if(fildes%2==1)\n"
  "    --fildes;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(!__CPROVER_pipes[fildes].widowed)\n"
  "  {\n"
  "    __CPROVER_pipes[fildes].widowed=1;\n"
  "    __CPROVER_pipes[fildes].next_avail=__CPROVER_pipes[fildes].next_unread=0;\n"
  "    retval=0;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "_close",
  "#line 1 \"<builtin-library-_close>\"\n"
  "\n"
  "int close(int fildes);\n"
  "\n"
  "int _close(int fildes)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return close(fildes);\n"
  "}\n"
  "\n"
},
{ "write",
  "#line 1 \"<builtin-library-write>\"\n"
  "\n"
  "// do not include unistd.h as this might trigger GCC asm renaming of\n"
  "// write to _write; this is covered by the explicit definition of\n"
  "// _write below\n"
  "#ifdef _MSC_VER\n"
  "#define ret_type int\n"
  "#define size_type unsigned\n"
  "#else\n"
  "#ifndef __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#include <sys/types.h>\n"
  "#define __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#endif\n"
  "#define ret_type ssize_t\n"
  "#define size_type size_t\n"
  "#endif\n"
  "\n"
  "extern struct __CPROVER_pipet __CPROVER_pipes[];\n"
  "// offset to make sure we don't collide with other fds\n"
  "extern const int __CPROVER_pipe_offset;\n"
  "\n"
  "ret_type __VERIFIER_nondet_ret_type();\n"
  "\n"
  "ret_type write(int fildes, const void *buf, size_type nbyte)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if((fildes>=0 && fildes<=2) || fildes < __CPROVER_pipe_offset)\n"
  "  {\n"
  "    ret_type retval=__VERIFIER_nondet_ret_type();\n"
  "    __CPROVER_assume(retval>=-1 && retval<=(ret_type)nbyte);\n"
  "    return retval;\n"
  "  }\n"
  "\n"
  "  int retval=-1;\n"
  "  fildes-=__CPROVER_pipe_offset;\n"
  "  if(fildes%2==1)\n"
  "    --fildes;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(!__CPROVER_pipes[fildes].widowed &&\n"
  "      sizeof(__CPROVER_pipes[fildes].data) >=\n"
  "      __CPROVER_pipes[fildes].next_avail+nbyte)\n"
  "  {\n"
  "    for(size_type i=0; i<nbyte; ++i)\n"
  "      __CPROVER_pipes[fildes].data[i+__CPROVER_pipes[fildes].next_avail]=\n"
  "        ((char*)buf)[i];\n"
  "    __CPROVER_pipes[fildes].next_avail+=nbyte;\n"
  "    retval=nbyte;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "_write",
  "#line 1 \"<builtin-library-_write>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#define ret_type int\n"
  "#define size_type unsigned\n"
  "#else\n"
  "#ifndef __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#include <sys/types.h>\n"
  "#define __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#endif\n"
  "#define ret_type ssize_t\n"
  "#define size_type size_t\n"
  "#endif\n"
  "\n"
  "ret_type write(int fildes, const void *buf, size_type nbyte);\n"
  "\n"
  "ret_type _write(int fildes, const void *buf, size_type nbyte)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return write(fildes, buf, nbyte);\n"
  "}\n"
  "\n"
},
{ "read",
  "#line 1 \"<builtin-library-read>\"\n"
  "\n"
  "// do not include unistd.h as this might trigger GCC asm renaming of\n"
  "// read to _read; this is covered by the explicit definition of _read\n"
  "// below\n"
  "#ifdef _MSC_VER\n"
  "#define ret_type int\n"
  "#define size_type unsigned\n"
  "#else\n"
  "#ifndef __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#include <sys/types.h>\n"
  "#define __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#endif\n"
  "#define ret_type ssize_t\n"
  "#define size_type size_t\n"
  "#endif\n"
  "\n"
  "extern struct __CPROVER_pipet __CPROVER_pipes[];\n"
  "// offset to make sure we don't collide with other fds\n"
  "extern const int __CPROVER_pipe_offset;\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "ret_type __VERIFIER_nondet_ret_type();\n"
  "size_type __VERIFIER_nondet_size_type();\n"
  "\n"
  "ret_type read(int fildes, void *buf, size_type nbyte)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if((fildes>=0 && fildes<=2) || fildes < __CPROVER_pipe_offset)\n"
  "  {\n"
  "    ret_type nread=__VERIFIER_nondet_ret_type();\n"
  "    __CPROVER_assume(0<=nread && (size_type)nread<=nbyte);\n"
  "\n"
  "    __CPROVER_bool error=__VERIFIER_nondet___CPROVER_bool();\n"
  "#if 0\n"
  "    size_type i;\n"
  "    for(i=0; i<nbyte; i++)\n"
  "    {\n"
  "      char nondet_char;\n"
  "      ((char *)buf)[i]=nondet_char;\n"
  "    }\n"
  "#else\n"
  "    if(nbyte>0)\n"
  "    {\n"
  "      size_type str_length=__VERIFIER_nondet_size_type();\n"
  "      __CPROVER_assume(error ? str_length<=nbyte : str_length==nbyte);\n"
  "      // check that the memory is accessible\n"
  "      (void)*(char *)buf;\n"
  "      (void)*(((const char *)buf) + str_length - 1);\n"
  "      char contents_nondet[str_length];\n"
  "      __CPROVER_array_replace((char*)buf, contents_nondet);\n"
  "    }\n"
  "#endif\n"
  "\n"
  "    return error ? -1 : nread;\n"
  "  }\n"
  "\n"
  "  int retval=0;\n"
  "  fildes-=__CPROVER_pipe_offset;\n"
  "  if(fildes%2==1)\n"
  "    --fildes;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(!__CPROVER_pipes[fildes].widowed)\n"
  "  {\n"
  "    for(size_type i=0; i<nbyte &&\n"
  "      __CPROVER_pipes[fildes].next_unread <\n"
  "      __CPROVER_pipes[fildes].next_avail;\n"
  "      ++i)\n"
  "    {\n"
  "      ((char*)buf)[i]=__CPROVER_pipes[fildes].\n"
  "        data[__CPROVER_pipes[fildes].next_unread];\n"
  "      ++__CPROVER_pipes[fildes].next_unread;\n"
  "      ++retval;\n"
  "    }\n"
  "    if(__CPROVER_pipes[fildes].next_avail==\n"
  "        __CPROVER_pipes[fildes].next_unread)\n"
  "      __CPROVER_pipes[fildes].next_avail=__CPROVER_pipes[fildes].next_unread=0;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "_read",
  "#line 1 \"<builtin-library-_read>\"\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#define ret_type int\n"
  "#define size_type unsigned\n"
  "#else\n"
  "#ifndef __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#include <sys/types.h>\n"
  "#define __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#endif\n"
  "#define ret_type ssize_t\n"
  "#define size_type size_t\n"
  "#endif\n"
  "\n"
  "ret_type read(int fildes, void *buf, size_type nbyte);\n"
  "\n"
  "ret_type _read(int fildes, void *buf, size_type nbyte)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return read(fildes, buf, nbyte);\n"
  "}\n"
},
{ "QueryPerformanceFrequency",
  "#line 1 \"<builtin-library-QueryPerformanceFrequency>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <windows.h>\n"
  "\n"
  "BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __int64 result;\n"
  "  lpFrequency->QuadPart=result;\n"
  "  __CPROVER_bool error;\n"
  "  if(error) return 0;\n"
  "  __CPROVER_assume(result!=0);\n"
  "  return 1;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "ExitThread",
  "#line 1 \"<builtin-library-ExitThread>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <windows.h>\n"
  "\n"
  "VOID ExitThread(DWORD dwExitCode)\n"
  "{\n"
  "  // never returns\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "CreateThread",
  "#line 1 \"<builtin-library-CreateThread>\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <windows.h>\n"
  "\n"
  "HANDLE CreateThread(\n"
  "  LPSECURITY_ATTRIBUTES lpThreadAttributes,\n"
  "  SIZE_T dwStackSize,\n"
  "  LPTHREAD_START_ROUTINE lpStartAddress,\n"
  "  LPVOID lpParameter,\n"
  "  DWORD dwCreationFlags,\n"
  "  LPDWORD lpThreadId)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  DWORD thread_id;\n"
  "\n"
  "  if(lpThreadId) *lpThreadId=thread_id;\n"
  "  __CPROVER_ASYNC_1: lpStartAddress(lpParameter);\n"
  "\n"
  "  HANDLE handle;\n"
  "  return handle;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "__asm_fnstcw",
  "#line 1 \"<builtin-library-__asm_fnstcw>\"\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "void __asm_fnstcw(unsigned short *dest)\n"
  "{\n"
  "  // the rounding mode is bits 10 and 11 in the control word\n"
  "  *dest=__CPROVER_rounding_mode<<10;\n"
  "}\n"
  "\n"
},
{ "__asm_fstcw",
  "#line 1 \"<builtin-library-__asm_fstcw>\"\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "void __asm_fstcw(unsigned short *dest)\n"
  "{\n"
  "  // the rounding mode is bits 10 and 11 in the control word\n"
  "  *dest=__CPROVER_rounding_mode<<10;\n"
  "}\n"
  "\n"
},
{ "__asm_fldcw",
  "#line 1 \"<builtin-library-__asm_fldcw>\"\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "void __asm_fldcw(const unsigned short *src)\n"
  "{\n"
  "  // the rounding mode is bits 10 and 11 in the control word\n"
  "  __CPROVER_rounding_mode=((*src)>>10)&3;\n"
  "}\n"
  "\n"
},
{ "__asm_mfence",
  "#line 1 \"<builtin-library-__asm_mfence>\"\n"
  "\n"
  "void __asm_mfence(void)\n"
  "{\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ "__asm_sfence",
  "#line 1 \"<builtin-library-__asm_sfence>\"\n"
  "\n"
  "void __asm_sfence(void)\n"
  "{\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ "__asm_lfence",
  "#line 1 \"<builtin-library-__asm_lfence>\"\n"
  "\n"
  "void __asm_lfence(void)\n"
  "{\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
},
{ 0, 0 }
}